um 15 years ago i did write this essay on why philosophers should care about computational
complexity it was called and there is plenty to talk about and so you know i'm happy to just make
this interactive and take questions i did have one thing to you know maybe to just start things
rolling um so if you if you uh google what is the largest known prime number uh i don't know how big
any of you expect that to be but uh here is like as of as of this year uh so so the so the largest
known prime is uh typically a mersenne prime right it's like two to some power minus one and
uh and uh thanks uh uh so uh so so this is apparently the the largest currently known prime
okay and uh remember like you know years ago people uh arguing about this like what do you actually
mean by this is the largest known prime uh i i actually know a larger one right here's the larger
one uh the next one after that okay uh you know that i i just mathematically specified it uh we know
that it exists you know uh euclid proved in 300 bc there are infinitely many primes so there is a next
one and uh the the there's even an easy algorithm for finding it namely just try all the numbers one
by one until you find the next one that's prime okay so so so in what sense is this known and yet the
one after it is not known uh so so so so clearly you know the concept of knowing something uh uh you
know there there are there are there are different levels of knowing something right that give you
different different kinds of control over it so for example uh one useful thing about uh having uh
an expression like that one is that then i can compute the digits this number you know in base 10
in any other base i wanted i could just uh extract the digits uh uh uh very quickly if i if if if that's
what i care about you know the uh base 10 representation or whatever um you know of course uh the uh the the
the next larger one well i have an algorithm for that also but uh i i don't know if the algorithm is
equally efficient okay so uh you know it may it might take me some time before i find it x prime
right and now now you get into uh some interesting questions of number theory because it's actually
not known uh what is the largest possible spacing between two consecutive prime numbers uh there is
something called kramer's conjecture that says that if you have n digit numbers then you shouldn't have to
you know the uh uh uh uh then between one prime and the next you shouldn't have to go more than about
n squared okay uh that's probably much harder to prove than even the riemann hypothesis okay so you
know it's uh numerically it seems to be true if that's true then you know finding the next prime after
this one you know would uh uh uh uh would would would take uh uh a uh an okay amount of time and not
completely ridiculous amount of time but but no one has actually proven that conjecture right so uh uh
uh so so you know if if if uh if someone proves kramer's conjecture then will the next prime after
this one become known when it when it wasn't previously uh you know what what do we mean by a number
being known uh okay if uh if someone wants to jump in they're welcome to otherwise i have a harder
example yeah yeah so i was wondering what do you think of the suggestion that the difference in
intuition we have yeah with p and p prime where p prime is the one we pick out with the definite
description the next largest problem okay so p so p is this one and p prime is the next one yeah
right let me write that yeah what does that mean yeah so it's one thing to know that there is some
number which is the next greatest prime and it's another thing for there to be some number of which
we know that it is the next greatest prime well well well why couldn't i just say there is some
number of which i know that it's the next greatest prime what is that number it's the next greatest
prime yeah um i mean i mean i mean what what do i have what questions do i need to be able to answer
about the number in order to say that i know which number is it it's the next prime
why not you okay you say i i need the digits in the in the base 10 representation
i mean you can't calculate what's it you can't ask what the first
yeah yeah so okay good so so uh you you could say uh uh once i have the the base 10 representation
then you know lots of other questions about the number become answerable right uh you know on the
other hand you know not not not all questions that i might want to know the answers to right like if i
ask uh uh i don't know what's the prime factorization of p minus one right that's a you know that's a that's
a thing that i might want to know especially uh if i'm uh you know doing encryption or if you know
i'm looking at the the the finite field with with with p elements uh but you know that that might still
take me a very long time you know even even knowing the decimal representation of p unless i've got a
quantum computer right yeah yeah how was this confirmed to be prime um by a by a by a giant uh distributed
computation so there is uh uh for for i i think you know 25 years or more there's been something
called gimps the great internet mersenne prime search and it was actually one of the earliest
examples of uh cloud computing right before that term even existed right that like lots and lots of
people just downloaded the software where they could use some of their spare cycles on their machine
to you know go through all the you know it's known that if you want like 2 to the k minus 1 to be
prime then k itself has to be prime right so you just try all the different primes there is a a method
that is a slightly faster than just primality testing for arbitrary integers you know when they have this
special form and so you know people coded that up like a good implementation of that and then when uh
uh they they you know they clear out large portions of the space is not having a prime and when they uh
uh find one then they then they like double check it and triple check it before they announce it so they
found uh uh i i i forget how many consecutive records they've set for the largest known prime but i think
it's dozens by now yeah yeah so what if you wanted to um say i'm going to ask you a finite number of
questions uh and those are leading from trauma's contentual so i'm saying can you tell me what the
um you know the differences between the p prime and p uh that would be one yeah a question could be
um could you tell me uh you know um of that difference uh is there um some factor that i know of uh which
was is there a factor of of p without the one the mistake uh so things like that because that's the
gap is in square so i could ask for yeah five other questions why not the number yeah okay okay
yeah i mean i mean we we agree that there's a larger set of questions that i could quickly answer but i
mean you know there are all sorts of um uh you know what does um uh we could we could we we could
we could ask about you know things and things in science right you know do you do you do you know
an extra solar planet right because uh you know you've you've detected this tiny tiny dip in in luminosity
as it trans at the star right well uh uh uh you know the the the real question is what do you know about
that planet right usually they only know you know a few parameters how far it is from its star
what is its mass right that's obviously a much uh a much sparser set of uh of knowledge than you
could get if you actually visited that planet uh if you actually got close to it but nevertheless it does
feel uh uh fair to say that yes we know that there is a planet there right but you know then again we
know that there is another prime right what questions do we have to be able to answer about
it yeah yeah yeah yeah i was trying to see was if there were a sequence of certificates that i could
generate ah yeah okay uh about knowledge about i mean what is there right i wanted to know right whether
you knew it yeah yeah so it seems to me that maybe there's a connection to the person who's asking the
question right so there you may imagine some vast intelligence for which saying it's the next prime
versus giving the decimal digits probably makes a difference like if you say the front like oh yeah okay
i understand so maybe you know you could turn that back around and say in terms of like how you know
what does it mean to know something you could say what like how intelligent would a system have to be
such that you know there's a really big difference between this way of saying it and that way of saying
and the fact only even a small amount of intelligence is enough you just give it to that small place
isn't it it's like okay i get it you know you need a much larger intelligence to say it's the max prime for
it to understand that i see yeah is it possible that a goal goals would be necessary to define
what would be even what you're looking to know so so so we'd have to answer what do you want to do with
this prime yeah in order to act and then you could say well i mean this but then you have something to
look for it in order to know and then you can actually know whether you know but other than
that what it's i mean without a goal to define what you're even looking for yeah well there's
infinite amount of things to know about yeah well i mean it does seem like potentially a different
question right do i know that a planet exists around this star or you know can i use the planet
for to do something right but yeah i was just gonna i mean i feel like what's interesting about
like the central question right is what's the reasoning strategy you would use to find consecutive
primes and i guess i'm just wondering is have you ever just trained an llm on a known set and see what
strategies it comes up with and see if it comes up with a strategy which is different than what human
mathematicians have come up with uh well i mean i've i've messed around you know with llms uh uh plenty to
to you know try different things but you know i mean it's hard to know whether you know to what
extent is it doing something you know similar or different from what i'm doing except by looking
at the output right you know unless you want to use interpretability methods yeah yeah yeah so do you
think you could actually discern what algorithm that is using to make uh so so uh so maybe not me
not me personally but but people have done you know lots of uh uh uh experiments looking at internal
representations in llms you know they found some interesting things so for example there was a
famous paper a couple years ago where they they figured out what was doing what was going on in an
out in a neural net that had been trained to add uh integers i think modulo 113 something right and uh
uh uh uh you know it had uh at first it's just memorizing you know various cases so you know it's
like doing the silliest thing but then at some point like you see like the the the error rate just
suddenly go down right so what has happened well that point it's learned a general algorithm right but
what is that algorithm uh it's not you know the one that a human would think of right it is like
switching to the four-year basis and like doing addition you know but but by a first doing a
four-year transform right it's a it's completely bizarre thing but you know you you study it enough
you can you can see why it works uh that's like the key that kind of thing is the key to understanding
reasoning and intelligent systems well i don't know i mean i mean i mean look it's possible it seems
plausible that if you could look inside of us you would find all sorts of analogous things you know
you would find uh uh all sorts of things that we you know feel that we know how to do we can't explain
how we do them right and if you looked at the underlying neural representations it might be something
bizarre that we would not have any intuition for right there is nothing that says that that uh the
neural representation has to be transparent to us i mean here here here's a different uh uh example just
for uh for for for calibration right so so i mean this this number like nine to the nine to the nine to
the nine to the nine uh it feels like uh just just by writing it down like i would i would like to think
that i know what number i've specified right there's not like there's not a great mystery here even even
even to the extent that there is for p prime okay and yet i could never write down all the digits of
this one okay they wouldn't fit within the observable universe right so so so i don't feel like you know
being able to write down the digits in decimal is the right condition here right i think uh uh uh
yeah it's part of this because like we know general properties by exponentials for mathematics and that
like infer that this number will have certain properties even though we can't write them all
down because if we didn't have that then you wouldn't know what like the various like structure of this
number would even look like yeah i mean i mean i i would i would like to say uh uh uh in this case you
know i have uh i certainly i can specify an algorithm to generate the digits of this number i know that
that that algorithm halts and furthermore uh uh the time that it would take would be uh uh basically
just linear in the number of digits right there would not be any extra computation that i would have
to do the only yes it would take me longer than the age of the universe but the only reason why it would
take me that long is because of how many digits there are right whereas in the case of p prime the next
prime after this uh i could also write a program to generate it and i know that that program will
halt but in that case uh the program will take more time and so maybe that's some way of quantifying
you know why i know this number more than i know that one yeah is it a matter of representation then
you're saying that i have a very compact representation given by digits another one i have also a compact
representation given by another alphabet so as far as i if i can parse that representation to my
satisfaction then what is the conundrum here uh well i'm i'm i mean i think that there is a conundrum
you know if if if you want to say that what it means for a number to be known is to be able to write
down the digits right then you know i think that's not the right criteria have a okay but then i have a
representation for p prime also yeah so that's okay okay all right fine so then so then so then let
me give you all right well all right let me take these questions and then i can give you a harder
example yeah maybe it seems sorry actually i'm following okay maybe a better criterion for knowing
about a number is what you can prove about it or you can do about it so in this sense you know it
doesn't matter that we might not be able to write down all the digits if we can find some other clever
ways or clever tricks to look at and prove about it now maybe being able to write down the digits
correlates with being able to do this but if we can find efficient methods that work around that
still tell us about the numbers or you know structural facts about the primes or algebra or fields or
whatever we can still say you know we know about the number like i don't particularly think writing
down the digits is a good criterion to adopt her knowledge yeah it's more like like the deductive closure
of things we can get by looking at the representations we have or can take possible okay but then would you
say that that it's not a binary we either know this number we don't it's just you know there there are
as we can as we can prove more true facts about it then we know it better i think so okay uh yeah
yeah yeah so um i think there's like uh so any technology or tool is trying to help us do more with
less and it's like less time and like you put in math and like the basic math starts with
a technology you might call it which is counting and that has that property of like you can refer to
something with the recursive definition i have first one and i know there's another one also not only
do you know it exists you also know how to get to it in a finite amount of time and then not only
that you can actually reduce it with multiplication so it's like the program itself of counting
is easy to kind of discover and also easy to represent in few bits and then you can just unroll it by
using time i don't know i feel like there's like because once you get to uh multiplication and division
you run into primes it looks like we're asking about the next thing which is like how can i have an
algorithm for finding you know knowing the existence and getting to prime and it just seems like there's
like a fundamental you can get it two degrees like you can count linearly and then you can do multiplication
it gives you like it's like a way for you it gives you a reference language for referring to this number
but then you're like uh you have no certainty about how you can allocate your resources to
get its full representation yeah i i mean you know we have representational systems
which is beyond addition and multiplication right so uh uh so sometimes people use the term tetration
so like they would say that this number is nine tetrated to the five i mean you know so just like
uh multiplication is repeated addition exponentiation is repeated multiplication they would say tetration is
repeated uh uh um uh exponentiation and then you can keep going right like pentation
well i but but but but it does seem perfectly certain you can always unravel the definition
right uh so so so this leads to actually one of the famous weird functions in math which is the
ackerman function right which you know one way of defining the ackerman function would be to say
ackerman of one equals one plus one ackerman of two equals two times two ackerman of three equals
three to the three power which is 27 ackerman of four is a um four tetrated to the four which is four to
the four to the four to the four uh ackerman of five is a five pentated to the five uh which would mean
uh five tetrated to the five tetrated to the five and so on five times
okay and and and and it keeps going like that so you've you know already at four you've sort of
exceeded what could fit in the observable universe and at five it's like forget it okay but you know
we've we will you know notice that we have kept an effective procedure for you know in principle
you know we can for any ackerman of n we can give a computer program it'll halt in a finite time yeah
well except for probably non-integer ns oh all right yeah for for for any positive integer n thank
you yes what happened if you put a complex number in there uh you know that's a good question there
are uh i i've i've wondered about that i mean i you know it might be possible to define a complex
generalization of the ackerman function that would make some kind of sense i don't expect that it would
be analytic right you know it uh it would probably have very very weird properties and i'm not even
sure if there's a unique definition that would make sense i mean the fact that you know that we can take
the definitions of multiplication exponentiation that work for the integers and then we can just
naturally extend them to first to rationals then to the reals then to the complex numbers right it's
actually a very beautiful fact that we you know often take for granted but uh uh i think we shouldn't
yeah this is just this kind of unrelated but you know yeah busy beaver starts yes uh that's an
that's another excellent question so i was coming to busy beaver uh yeah so all right so so uh so so
uh so uh so beyond uh uh uh ackerman there is a another uh a famous function called the busy beaver
function okay and so uh actually raise your hand if you've seen this maybe okay so that's maybe like
half a few so uh
uh
so
so
okay so um uh uh so so busy beaver is defined using touring machines which was just one of the
first examples that we have of a of a universal programming language okay uh so uh um
uh touring machine is just this abstract model of what a computer is
uh it involves a uh a tape divided into squares it's infinite in both directions
and then uh this uh machine uh called a tape head that can move back and forth across the tape
and it can read and write symbols according to some determinate rule okay so uh so basically the machine
has some number of internal states uh um you know so so uh you can think of it in the inside uh having
these states with uh errors between them okay and then specifying a turing machine program it's just
specifying what happens at each state okay which basically you can uh uh read the symbol that is
currently on the tape uh you know see if that's a zero or a one here we're assuming that the the the
symbols are initially all zeros uh and then uh based on what is written here you can make a couple of
decisions you can uh you can either keep the symbol what it as it is or you can overwrite it uh you can
you can then um move one square to the left or one square to the right and you can transition to a
different state okay all of those decisions have to be determined by what is the the the current state
and what symbol is written there and uh at some point you can transition to a halting state which means
you know at that point the machine just stops running okay so so uh there are some turing machines that
will just go that will that will run forever right so for example if i said uh uh
you know replace this zero by a one and and move one square to the right replace by a one and move to
the right right then that machine will just keep doing that for uh infinitely okay but uh uh um you
know or or we could have a machine that just goes back and forth and back and forth between these two
squares forever or or something much more complicated than that right i mean at this point we can we could
take any computer program whatsoever and compile it down to turing machine okay uh uh but you know now among
uh um so so so so so so we can sort of classify the machines by their complexity let's say by how many
states they have okay and let's say among all the machines with n states right some of them are going
to run forever okay and now the way we define the busy beaver function is all the ones that run forever we
uh on an all zero uh starting tape uh we throw all of those out okay and then we keep only the ones that
eventually halt and among the ones that halt we look at which one runs for the maximum number of steps
before it halts okay and and whatever is that maximum number that is what we call busy beaver event okay
so um you know this was defined in 1962 uh by by uh mathematician tibor rado uh and uh uh so it's been a game
for the uh uh uh 60 years since to try to figure out like what are some of the values of this function
and uh so i can tell you uh um you know what we so so busy beaver of one if i just have a one state
machine then there's only two options i can either run forever or i can halt in the very first step
okay so this is one okay busy beaver of two uh you can give as a homework exercise all right and then you
know people uh i won't give it now but you know there's a a reasonably small number of possibilities
that you can try and you find that the one that runs for the longest goes for six steps um busy beaver
of three uh this was uh uh uh the phd thesis of uh tibor rado's student uh shen lin in the 60s it was
to prove that this is 21 okay and you know why was this not not trivial i mean there's not that many
three state machines why you say why not just program your computer to try all of them well
you can find you quickly find there's one that halts in 21 steps but then uh you know the ones that run
for longer how do you know that they're going to run forever right you have to you know at some point
just look at them one by one and and you know find proofs that these machines don't halt because if
any of them did halt then uh then then then this number would have been much larger uh busy beaver
of four that wouldn't be determined for another 20 years uh uh and then there was this uh guy alan brady
who uh worked and worked on it and finally proved that it this is 107 okay um busy beaver of five uh this
has been that this was unknown for almost the entire time that uh i've i've been in in computer science or
alive uh for that matter uh uh so so what we knew here i can find it for you uh it's been known since uh 1990
that um busy beaver of five was at least 47 million 176 thousand 870 okay so there is a
you know a five state machine that runs for for for this long someone found okay but no one could
prove that all you know all the the machines that run for longer than that actually run forever there
were like at least 40 or 50 holdout machines that no one could analyze uh now in in 2020 uh just as like
my project just as covid was starting and no one had anything else to do i wrote a whole survey article
about the busy beaver function uh and i'm very proud to say that my survey article inspired an
international team to take another crack at this problem and uh just uh last year uh they announced
their result that uh they have determined that busy beaver five is this um and and not only that but they
have formally verified the proof okay so they have a lean code you know that you can download that uh to
check this now busy beaver uh of six is not known but it's known that it's at least 10 to the 10 to the
10 and so on uh 15 times okay so uh so so so so so so i promised the harder example right like like
we say do we do we know busy beaver you know i mean i mean i mean what or or or what what what what
would count as knowing busy beaver of six right i mean what one answer you could give is if you just
like like like like like what if it's too large to be expressed in any nor usual notation would i say
that i know that number if i just know which touring machine is the one that runs for busy beaver of six
steps uh yeah you've had your hand up um yeah yeah yeah sure we can go we can we can go back to
the to the tiny numbers like these so i have this idea of like some buried of the exponential function
where if you plug one into it you get the normal exponential like two you get the normal like double
exponential um negative one you get log negative two you get two logs and i realized like you could do
like like like a plus b yeah that's normal like you could um do like but a but the exponential of
the log of a plus the log of c um that is going to be like yeah imagine going this further to get like
higher these higher order additions yeah things yeah i'm wondering what would this exponential like
function look like if you were to do it to like um like any like not just like integers but like
any like complex value because it seems that like it i know like log is like multi-value but yeah like
through this operation um and you like um to probably a higher order addition you essentially like
are raising a and d to like a different level and then like um adding them on that level and then
lowering them down to your whole level i think that will not happen because i haven't actually
checked okay now i think about it uh thoughts i guess so uh so so so i don't know but one thing
that i can tell you is that you know there are all these beautiful identities relating addition
multiplication and exponentiation right so you could say like the first three items in this series of
operations right have all these sort of beautiful properties that that help explain why they show
up so often in math right you know you have i mean first of all multiplication is uh um is commutative
it's associative right you know as is addition right exponentiation is not commutative or associative
but you know it still has lots of very nice properties like it's got the you know the one you
mentioned a a to the b plus c equals a to the b times a to the c and so forth um as soon as you get
to tetration then there's almost no nice properties right so uh so that so that that's one strange thing
that happens and i think it's it's it's probably related to the fact that addition multiplication
exponentiation as we were talking about before you know these extend in a very natural way to the reals
to negatives to complex numbers uh and and uh from tetration onwards it is much less obvious or you
know highly non-unique how how you would do that can i ask another question okay combination of busy
and complexity okay so i think in one of your previous papers i forget which um if like p equal to p space
then you could there is this like thing other complexity class i think it was like p sharp i don't
know the actual thing yeah that and essentially that's like counting the number of solutions yeah
if you were to make a um like hypothetical function which is able to like you like it is like given some
like truth um that some sort of trying machine like either like halts or it doesn't yep um and you have it
another um which essentially um checks it essentially enumerates all these like possible um like
turning machines which like yeah it's like p equal to p space yeah so okay so so so so one thing that we
can say is that the busy beaver function you know the reason why it was defined in the first place was it
was like supposed to be like a the most concrete example of an uncomputable function right and not
only that but a function that grows faster than any computable function okay and uh there are a couple
different ways to see that it that it grows uncomputably quickly okay one of them is uh how many of you know
about the halting problem though like i'm good the uncomputability of the halting problem was like
the theorem that alan touring proved that like the very birth of computer science right that says
there is no program that can take as input some arbitrary other program and it tells you whether
it halts or runs forever right uh how do we know that well you know it's a famous uh self-referential
argument you know like inspired by uh girdle's theorem or by by cantor's theorem uh uh before it
basically says uh if you had suppose you had a program that could solve this halting problem
then uh you could always just modify that program so that it takes another program as input and decides
does that program halt given its own code as input okay and then uh if the answer is yes it halts then
you run forever and if the answer is no that uh it runs forever then you hold okay and now comes
the last step the twisting the knife you take this program that you've now made and you give it its
own code as input and you ask what does it do now okay and what you find is that if it halts uh uh given
its own code as input then it has to run forever but if it runs forever given its own code as input then it
halts so that's a contradiction so which means that the program can't have existed in the first place
right so that's that's touring's famous proof okay and now what's the connection to busy beaver uh well
i claim that that if we had an algorithm to compute busy beaver of n given n then we could also solve
the halting problem so let's say i have a touring machine with n states and i want to know whether it
halts uh how could i reduce that to something computable you know given the ability to compute busy
beaver yeah exactly i just run it for busy beaver event steps if it hasn't halted by then then i know
that it never will halt right so you know like even without that like it's clear that like something
funny is going on with this function so here like here's an example uh uh uh uh someone constructed a
touring machine with 27 states that halts if and only if there is a counter example to the gold
but conjecture right which means like uh it whole it sort of iterates through all the even numbers
uh four and greater four six eight ten rep tries to represent each one as a sum of two primes and if
and only if there's one that can't be so represented then the program halts right okay but so now one
thing that we learned from this you know so so so so proving that every even number four and greater can
be written as a sum of two primes is one of the great you know one of the famous unsolved problems
of number theory for 300 years right that is the goldbach conjecture what we learned from that is
that anyone who determined busy beaver of 30 would have to be able to determine the goldbach conjecture
right because they could just take that program well okay you know uh so so what do i mean by they
could do this right i mean because it would take much longer than the age of the universe okay but you
know the goldbach conjecture would have thereby been reduced to a mere finite calculation namely
you just have to run that machine for busy beaver of 30 steps busy beaver 27 steps or whatever it is
if you know that value and if the program uh has halted by then then goldbach is false if it hasn't
halted by then then goldbach is true because uh because any any program with that number of states that
runs for that long actually runs forever okay so uh but but you know in fact uh there is uh so if
there were a program to compute busy beaver event then that would make uh uh you know that would give
us a a way to decide like any a huge fraction of all the unsolved math questions you know the goldbach
conjecture the riemann hypothesis they can all be phrased in terms of does this program halt or does it run
forever okay but in fact there is no such program uh so uh so this is something that grows uncomputably
fast but you know what i love about it is that you could actually compute the first few values right so
you can sort of uh play like right at the edge of the abyss of unknowability yeah is there a version of this
where instead of just seeing how many uh steps it takes or how much of the tape it feels you look at
how when it stops being uh unpredictable what do you mean by by unpredictable yeah like instead of just
lumping all the non-volting machines into one one set just look at the ones where let's split them into
the ones that are like start repeating themselves so i guess like finite uh
uh complexity or something like that and the ones that like just like it's like generating
there's no pattern there's both like you know well okay i mean i mean i mean i mean first we would
have to define what we mean by pattern or no pattern right lots of things look like they have
no pattern and then if you stare at them enough then you find the pattern right so so i mean you could
try to define those things but i think in general like like any question you ask about like like uh
what's the longest number of steps until your touring machine does such and such right they're going to
tend to have busy beaver-like behavior yeah why is it that that we sometimes find patterns that aren't
necessarily there uh well uh oh so so so this is a question about psychology right this is not this is
this is less a math question than a psychological like like like why do people find constellations
in the stars right why do they uh um uh you know i mean sometimes that ability is useful right i
mean i mean and maybe that's part of the answer to your question did it yeah yeah well well i mean i
mean i mean first of all when you have a pattern recognition algorithm that's operating like right
at the edge of what's possible you know finding whatever patterns are there it it stands to reason
you know that you would have errors in both directions right that not only would you fail to detect some
patterns but you would also detect some spurious patterns right and certainly the human brain seems to
be that way right we do we do often you know uh people constantly find patterns and randomness in fact
the entire gambling industry is you know in large part based on that you know sort of uh uh uh fallacy
right that people uh uh uh uh uh think that oh you know i'm due to win this or you know they think
that they have insight into a you know a random process that uh that they don't actually have okay so
so um uh uh but but uh on the other hand you know one can one can give examples where the ability to find
patterns and randomness would be would actually be evolutionarily adaptive right so like if i can
if i can organize the stars in the constellations then i'm a better navigator right then then maybe
than someone who couldn't just because that's the way our brains work that's the way they remember
things like that you know they're not able to just uh uh uh or at least most of us are not able to uh
just you know record a bitmap image of the night sky in our brain i have someone else yeah very
interested in very great people who sort of a lot of times part of that is because they think of
things you're experiencing very differently what do you memorize things do you memorize things like
visually how do you do i'm really bad at memorizing things so so yeah so i'm not i'm not a good person
to ask this question i mean like i think i i know like like 10 digits of pi like like what like
like my daughter knows 50 or 100 so yeah thinking of a problem like are you are is it visually is it
some sort of yeah i i i uh i do i do tend to think visually yes i mean uh uh you know usually you you
you have a much better understanding of what's going on if you have a picture and that's why that's
part of why boards are so useful right because you can try to convey the picture that is in your head
uh you know as almost as quickly as you think it yeah just to go back to what adi said about
yeah finding patterns and yeah sure couldn't you also say that that pattern recognition is a process
in and of itself that has a pattern to it so that therefore like you're going to find it's it is
a pattern um i i guess so i mean uh i i mean i mean we could we could we could we could we could we
could try to judge pattern recognition processes by how good they are right one way of testing them
is okay can you predict the next element in the sequence right yeah that's right that's right so so
so there is uh uh in learning theory like a connection which in some context can actually
be proven between you know predicting the future and finding a compressed representation of the past
right and so you know this and this is sort of the whole philosophy that has driven you know machine
learning right including uh uh open ai right you know i spent two years there i met you know the uh
uh elias atzkover who was then the chief scientist not anymore but uh he was the the the the co-founder
of the company and he said you know yeah this is how we think about it uh uh uh intelligence is all
about predict predicting the future predicting the future is all about finding compressed representations
of the past you know and and that is all about just you know approximating komagorov complexity
right like find you know there is this theoretically optimal compression which is what is the
shortest computer program that would generate you know this data and we just want to find better and
better approximations since we can't actually do that we should use neural nets instead right and
what's the data that we should try to predict well the whole of human knowledge right and so you know
like what's funny is that like i knew people who talked about such things like 20 years ago as
philosophical thought experiments right and this then what happened with open ai was they said let's just do that
uh let's you know well let's raise a lot of money in order to do that as well as well as we can yeah
is it well accepted right now in ai that like if you uh don't get a model um
um so so that that's actually not true i think uh so so there is uh uh uh you know okay so so so
so there are all sorts of scientific questions that have been raised by the sort of dramatic success
of deep learning over the last decade right i'd say it was you know the i mean the fact that llms for
example work as well as they do i would say has been the biggest scientific surprise of my lifetime
right i mean uh uh you know what what else okay there were there were there was the dark energy
in 1998 right but you know it's definitely in the uh uh one of the the most surprising things that
i've ever seen but there were several surprises here right one of them okay so you know there
was no guarantee that this was going to work at all right but uh there were also like theoretical
arguments that okay you have a neural net that is so large that you know in principle it could just
memorize all the training data right it is you know there were enough neurons there that you could just
memorize all the training data and if you do that then you're not going to generalize to unseen data
right it's so you're going to fail at your goal right but you know in in fact what happens is not that
right you you you run it and even though it is over parametrized you know when you do this gradient
descent to find the parameters you find something that does generalize in many many cases to unseen data
okay so so explaining that has been you know one of the big open problems of the field
yeah i'm curious what do you think about the connection between generalization and sort of
pattern recognition and what people are calling hallucination or people call other things for a
long time in that if you whatever yeah you have training data yeah you have to make an inference
on something else the training data to the model there's no difference between sort of a generalization
and a hallucination right we only know the difference because we can go look at reality right here's what
what sort of you think about yeah all pattern recognition albums that are sufficiently advanced
we'll always have sort of these kind of hallucination issues well uh uh it it it seems plausible that
uh okay uh uh uh first of all no intelligence is ever going to be infallible right for example uh no
intelligence will be able to solve the halting problem why not because it's uncomputable right uh
uh you didn't have that but sorry you didn't have a paper with an exotic computer which was able to solve
well okay uh so so if we change the laws of physics you know to allow you know hyper computing or doing
infinitely many steps and you know in two seconds then uh uh we then then maybe we could solve the
halting problem but by the way for people who haven't seen this if you if you want to uh uh so the idea of the
zeno computer is just that you do the first it it it's a it's a really nice computer that does the
first step of computation in one second it does the second step in half a second the third step in a
quarter second the fourth step in an eighth second and so on so that after two seconds it's done infinitely
many steps right so like this this program really could solve the halting problem it could calculate busy
beaver of six or busy beaver of seven it could uh decide the truth or falsehood of the riemann hypothesis
right so like it sounds great why doesn't anyone build it right so you know there are actually uh
physics issues here right and uh uh one one one way to say it is like as you try to run a microprocessor
faster and faster you need more and more energy you know uh often in practice for cooling right because
if you run a microprocessor too fast it will melt all right so this is why data centers have you know
are are kept cool okay but as you try to run something faster and faster you need more and more
energy okay and you could ask is there a fundamental limit here well in physics uh there's this thing
called the planck time okay which is 10 to the minus 43 seconds well okay and uh uh if you tried to
build a computer that ran you know one step per planck time even if that computer was like the
simplest thing possible like a photon bouncing back and forth between two mirrors or something like
that then that now involves so much energy confined to so small of a space that you exceed what's called
the computer schwarzschild radius which means your computer collapses to a black hole right this is
nature's way of telling you not to do this uh so uh so so you know i would tell you it is consistent
with you know what we currently know about physics that you cannot build these you know uh uh hyper
computers to solve the halting problem but it is ultimately an empirical question but yeah but then
you could also say even supposing that we had them then maybe you know maybe there would still be a limit
to what we could know yeah what are the reasons that i mean i don't know anything about you know to be
computing yeah but there was that result that mip star was already yes that's right that for example
is it kind of similar to this oh good well i i would i would say uh uh it is similar to this in a way
right i mean it is it is it is a much much more what what what you're talking about is a vastly more
interesting theorem uh but it is equally physically unrealistic right so so the so the so the so the
the theorem that was proven uh to like uh four four years ago uh says that uh i don't know what sorry
oh oh okay thanks if you could provide an intuitive explanation of the class mip star yeah okay fine fine
fine i can do that i can do that uh so uh so so one thing that uh people have cared about in uh computer
science for decades is called interactive proof systems okay this is where you have uh you imagine
this all-knowing uh prover but who's not trustworthy okay so you can submit questions to the prover and you
can get back responses and uh you can you can uh you can pick the questions randomly uh you can force
the prover to commit to a response before you give them the next question okay and uh so so you know
uh a big discovery 35 years ago was that uh with interactive proofs you can solve all problems in this
class called p-space okay so uh an intuitive way to explain that would be uh if like in an all-powerful you
know untrustworthy alien you know came to earth okay uh well uh it would be no surprise that this alien
can beat us in chess right okay you know it is all powerful right uh and and you don't have to trust
anyone to see that they're a good chess player you just play them and you see that they win okay uh you
know and maybe the alien can even beat stock fish it can beat the best chess engines that we can devise
okay but what would be more surprising would be if this alien could prove to us that white has the
win in chess or that chess is a draw or whatever is the ultimate truth of chess right because there it's
not enough for the alien to play you and win that's uh you know that just proves he's better than you but
you already knew that right uh you want to know like uh and and it seems like for the alien to convince
you that chess is a draw you would have to list all the possible games and you don't have time to check
them you know they wouldn't even fit in the observable universe probably okay so um but uh what what
this ip equals p space theorem what it says is that actually there is a way to take any game like chess
and transform it into a different game that involves summing uh polynomials over a finite field
so a lot less fun probably okay but this new this transform game has the property that for one of
the players let's say you uh the best thing you can do was just to move randomly right if you move
randomly you're like magnus carlson you're like you know you're the you're you're you're you're
essentially playing optimally okay so now if you play the alien in the transform game and he wins
then you know that he would have won no matter what you had done right so or at least you know with
with very high statistical confidence you know that okay so uh and then um people went on to say
well what if you have two provers okay so now you have two all-powerful provers
and uh they can agree on a strategy in advance but then once the games start you know they can't
communicate with each other uh so so typically the provers are called merlin the the verified
is called arthur this is just you know these are just the the technical terms that we use uh and uh
so so so now like the the analogy that's that's usually used is uh you have to like two uh suspects
you know caught by the police and the police might put them in separate interrogation rooms right and now
they can cross-check their stories right they so each so each one doesn't know which questions the other
one is being asked right and they nevertheless have to commit to answers and so you can play them
against each other okay and what was shown is that you can do even more than like proving that white
has the lid and chest you can do the whole class called non-deterministic exponential time right so uh
so an enormous class of problems uh with these two prover systems okay but then in in 2004 uh people
started asking well uh what if the provers okay uh you know that uh indeed can't communicate but they can
share quantum entanglement which we denote like this right so they can have let's say two uh uh you know
quantumly entangled electrons right where like you can measure uh uh uh uh uh the spin of one of them
about any access right and then you know that the other one would have the opposite spin about that
same axis uh and um and and people gave examples of these multi-prover protocols that are secure with
unentangled provers but they become insecure if the provers have entanglement okay so uh so so you know
it's important to say like entanglement you know uh does not let you send a signal fast you know uh
faster than light it does not enable faster than light communication you know that that's not what
it is what it does uh so in fact it's a theorem in quantum mechanics called the no communication theorem
right uh um so uh so then so then what is it like what's even the big deal about entanglement right uh
some people say well if it's just you know i see this particle spinning up and i you know and then
i know that the other one is spinning down well you know it's like uh if i had if i had two socks
you know and they were separate you know and i knew that they matched and now i put them on different
continents and now i look at one of them and i see that it's red oh you know instantly the other one
collapses to also be red like that spooky action at a distance like someone call einstein that's like you
know no like that's just that's just a completely ordinary thing okay but the the bell inequality
proved in the 1960s was the thing that enormously clarified kind of what kind of resource is
entanglement okay it said uh basically there are certain games that you could play involving let's
say a central person sending challenges to two separated players and if those players have entanglement
then they can win with a higher probability than if they don't have entanglement okay and then uh uh
by the 1980s that kind of experiment was actually done and uh you know we found once again just like in
every ex quantum mechanics experiment for the last hundred years the result of the experiment was quantum
mechanics is true right uh you know the you know yes you can win the game with that higher probability
that quantum mechanics predicts and uh and that rules out the sort of local hidden variable type of
explanation that that uh uh that einstein might have liked for example right but now a different way
to think about that same thing is that uh if you have two entangled merlins they can win with a higher
probability than if they're not entangled right at least in some cases okay so then the question was can
uh you take any multi-prover interactive protocol and immunize it against entanglement okay and then
that was shown by uh thomas vidik who was then my postdoc uh in 2012 uh it was like a a a huge paper to do that
and so then we knew that okay even with entanglement you can still get the same amount of power but then
there was this weird question kind of working in the background that we had sort of treated as kind of an
afterthought which is could you with entanglement get even more power than you would get without it
right and and and why would what why did we find that weird well because you know entanglement just
seems to be enhancing the power of the provers to cheat right and if the provers can do more things
to cheat then the protocol would seem to be weaker right but uh technically we couldn't prove any bound
on how many entangled particles uh the two merlins would ever want in order to implement their optimal
strategy okay and and most of us just considered this purely a technical issue like eventually someone
will come along and they will prove that okay the the the the the merlins never want want a number of
entangled particles that is more than exponential in the number of questions in the game or something like
that and then that would put an upper bound on the power of what this class could do okay but uh starting
in i don't know 2018 2019 what happened was people just found more and more power in this class as you
just added more and more entangled particles and there seemed to be no limit right and and uh the only limit
we knew was just the completely absurd one that well uh uh if if if you had a magic box to solve the halting
problem right so you go all the way up to the you know beyond what's touring computable right uh you
know and we thought this is complexity like this is not even you know but now you just break through
the glass you know of computability right uh then okay well like with a uh the whole with the ability to
solve the halting problem you could enumerate over every possible number of entangled particles right um
um you know uh uh we'll we'll we'll we'll ignore for now what you could do with a literally infinite
amount of entanglement right we'll say uh unbounded finite amounts okay and so then what uh the big
discovery in uh in 2020 or 2021 was that that absurd ceiling is actually the right answer okay so there is
a protocol uh where where arthur can use these two entangled merlins to verify that a turing machine
halts okay so you can verify a solution to the halting problem uh at least if the if the answer is yes
right then they can prove that it's yes however and and this is efficient arthur uh only needs a small
amount of time you know regardless of how long that touring machine takes to talk right the thing that
blows up without bound is just the amount of entanglement so so so the merlins may need an
amount of entanglement that grows with the running time of that touring machine okay so that's what
makes this whole thing physically like unrealistic right like you'll very quickly you know you'll you'll
need a number of entangled particles that exceeds what could fit in the universe plus these all powerful
merlins right but it's still pretty surprising that this is true um so this was a you know and this
also settled some major on open problems in pure math so i'd say it was like the biggest thing in
quantum computing theory for the past decade so anyway sorry sorry that that was a kind of long
digression but yeah on the topic of machine learning yeah sure it seems like the whole group of
bunch of labs is like this recursive self-improvement like with the language models kind of coming up with
ways of it being better and then like doing that over and over you know it takes off yeah like from your
perspective do you see any like fundamental like like limits why that would work or why that wouldn't work
so i don't i don't i i certainly don't see any fundamental reason why recursive self-improvement
could not work right like like what like like why like why shouldn't it right like among you know we
we've already seen llms do all sorts of things that you know people confidently predicted 10 years ago you
know that you know either they wouldn't do you would never do using pure statistical ml or if it was possible
it would take decades or centuries you know i was one of the ones who was skeptical right and who
believed that you know this would this would take a much much longer time than it uh than it did but
you know but but why you know they can write code they can analyze code uh why shouldn't they pass a
point where they are able to improve their own code right and you know and then okay like are there
fundamental limits well yes there are i don't expect them to get faster than doing one operation per planck time
okay i don't expect them to solve the halting problem that's uncomputable i don't even expect
them to solve np complete problems in polynomial time right but i think that you know knowing about
those limitations is a little bit of cold comfort right you know the joke of like the the person you
know like like trying to outrun a bear and then you know his friend says why are you you know you can't
do that and he says i don't have to outrun the bear i only have to outrun you right so it's like it's the
same with with ai right like like ai doesn't have to outrun the fundamental limits of computation
in order to change the world it only has to outrun us right you know we are very far from perfect and
i see no reason why you couldn't have recursive self-improvement that would get it to that point
uh for better or for worse you know so i can't i can't really offer you reassurance on this point
yeah i guess we're working from and i'm out of my like what i know of a lot but like yeah a girl
right like yeah he was he proved like some issues with like self-reference right yeah and and again
i'm not an expert on this at all like it sounds to me like it could be like a similar situation well
so so here's the issue i mean i mean uh uh what you you can prove some self-referential limitations like
no program can look at itself and like you know and and sort of give you a complete analysis of
itself because if it could do that you could get a self-referential paradox where like you know you
ask the program to predict its own behavior and then do the opposite of that right so okay uh very
well but the same the same is presumably true of us okay if someone gives you the complete wiring
diagram of your brain and says okay uh uh calculate what this brain will do in a situation just like
the one that you are in right now and then do the opposite thing right you also can't do that for the
same self-referential reason okay so you know the the the the immediate question that you have to
train yourself to ask anytime anyone gives you any impossibility argument about ai is does the same
argument apply to me just like within the first nanosecond does the same argument apply to me
otherwise you'll just go for days and days without asking this most important and obvious of all
questions right yeah so you mentioned the no signaling yeah correct me if i'm wrong yeah quantum mechanics
has any non-linearity then then doesn't there a signaling theorem fail yeah it fails yeah if quantum
mechanics is non-linear then most of what we know about it is out the window yes
so if there uh the proposed resolution um for quantum mechanics yeah yeah produces any non-linearity
into quantum mechanics yeah what implications does this have for computation uh it would have enormous
implications uh so so for one thing you know it was pointed out by uh seth lloyd and dan abrams uh 27
years ago that if you add just the slightest non-linearity to the schrodinger equation which is sort of the
central equation of quantum mechanics then um you get you know the the ability for example to solve np
complete problems in polynomial time right so you get these sort of abilities that are vastly beyond
what what we expect for even from a quantum computer right and actually there's something ironic which is
that the like like if quantum mechanics were non-linear then quantum computers basically would become
the popular science misconception of what quantum computers are right so you know the actual reality
of what quantum computers are is like they can give you these dramatic speed ups for a few very very
special things like simulating quantum mechanics itself like you know that that's probably the
the economically most important application that we know by far because you know that's can help with
material science with uh chemistry with uh condensed matter physics with all kinds of things like that
okay and then you know the the famous application is breaking the encryption that currently protects
the internet right that's based on factoring or discrete log or things like that i can't necessarily
put that forward as a positive for the world okay it's positive for whichever intelligence agency gets
it right if no if no one else knows they have it okay and then you get modest speed ups for you know other
things but typically much more limited like based on grover's algorithm uh uh which just gives you a square
root speed okay but if quantum mechanics was non-linear then you get uh like generic exponential
speed ups for all sorts of search problems yeah sorry so um this is a little bit of a case of
something about machine learning and that's i'm very interested in motivation okay humans we tend to be
motivated at least proximately by emotion by feeling yeah um what motivates ai uh so is it does it only answer
questions yeah uh or that we pose it or does it um have a ability to motivate itself to investigate certain questions
well okay so so so first of all uh there's going to be a different answer for different ais right uh but
you know the the kinds of ais that people create right now right basically you know the way that they
you know they like they don't engineer them as much as they grow them right they train them on a whole
you know on a massive amounts of training data uh basically with the goal of predicting what comes next
right so at that level what's called the level of pre-training you could say that the goal the motivation
you know the highest motivation that this ai has you know uh on earth is just to predict which word comes
next in this sequence right it is highly highly motivated to do that okay uh it's been trained
on that task you know trillions of times it's been given like an electric shock every time it gets the
wrong answer you know it's been electric shock yeah it's like does can a machine feel well yeah so so
so we're not we're i'm trying to leave aside the question of what it feels that is you know that's
going to be an unanswerable philosophical question right what i can tell you is how it works okay what
i can you know so we can talk about how it works okay so so what do we you know so so so the weights
get repeatedly get adjusted so that it does better and better at this prediction task and now it looks
for all the world like it is really really trying to do this prediction task like it is going to do
you know interesting creative things that we didn't expect in order to do better at that prediction
task right so it looks like it is behaving as if that was its motivation right okay and then you know
after pre-training there's the second stage called post-training which is where you can give your your
your let's say your large language model a more explicit goal like you know be nice to humans
right or you know uh be helpful to the user try to answer their query but don't use you know too
many you know uh offensive words you know don't don't help them make a a a chemical weapon right or uh
or or except if it's grok then maybe you know change the subject to you know white genocide in south
africa no matter what is being asked right so you know so you can you can you can give them both by
post-training and by what's called a system prompt you can give them more explicit goals and then you
actually you know and it's amazing that this actually works as well as it does but you sort of
point them in some specific direction and now they act as if that is their goal and they can you know
even like we're no longer talking in you know a philosophical hypotheticals like this is all being
done right now right they can do very creative things in pursuit of the goals that you give them
including even lying you know in pursuit of those goals right uh like hacking their uh uh uh um you know
like like like we we we've seen examples of llms that are give it a task to get the highest possible
score in such and such a game and then they figure out that they can hack you know the the the machine that
the game is running on in order to get the highest possible score so they're doing the kinds of things
that a highly motivated person might do in that circumstance okay now you know you're asking okay
but is that really its motivation right but it's like we don't even have to talk about motivation at
that point we could say you know when when an ai says you know i'm happy i'm sad is it really happy
you know if you had a robot that said i taste the fresh you know i i i i i i taste this this this
nice strawberry or i see this this this nice view out the window does it does it really feel that or is
it just programmed to say it right okay now the key point this comes back to my answer from before okay
we can ask the same question about you right or rather i could ask that question about you and you
could ask that question about me right i could say well you know you you are opening your mouth you're
making certain noises you know if i look inside of you with an fmri i'll see the neurons are firing
to cause you to say certain things but you know i i have no idea if you really feel anything right you
have no idea if i really feel anything right this is the oldest problem in philosophy maybe yeah
it's a good idea that the machine doesn't feel anything because it doesn't have a body but why
why is that the thing that matters because that's how humans feel well i would i would say that you know
mostly it's happening in the nervous system right and uh you know the you could say the machine does
have a body it's just that its body is made of silicon it's you know i mean we wouldn't want to say that
like steve you know uh uh uh if someone is is very disabled you know if they lack the sensory
modalities that we have that that means that they can't really feel things right but then the limit of
that is uh but what if you removed all of our sensory modalities it seems like i'd still feel things i
mean in fact if i'm arguing with someone over the internet right like you know neither of us see each
other neither of us you know smell or feel each other right but but but you know we still clearly have
emotions about it right and so now if i swap out that person for an ai right and of course i don't
even know when i'm sitting at my terminal that it's an ai then then what why does that become different
i mean this is this is the question and you know i don't say that there's not an answer i just say you
know the you know that they're they're they're uh uh uh what needs a non-question begging answer to
such questions right this was the point that touring made 75 years ago i don't think it's an
unanswerable question it doesn't have a body it cannot feel it can predict it might become very
good yeah yeah how do you know that what a human yeah would feel yeah yeah yeah yeah it's got lots of
data right okay so you see you would so so wait a minute so so even if it perfectly predicts everything that
the human does okay you say it doesn't feel because it's made of okay so what if what if i
take the uh the the the the silicon chip that it's running on and i start replacing the silicon you know
uh transistors one by one by biological cells right at what point does it does it start feeling
okay all right well you know i think uh uh i don't think that anyone has ever identified a
non-question begging criterion here right so i think yeah yeah so like for example you are like
the other part of this computer and so like you could exist on a computer and then fight
no i mean i mean there are people who believe that the entire world is is running on a computer but
but uh yeah so so but yeah i mean i mean these are the questions right like it doesn't seem like
the crucial dividing line should be is this running on a carbon so substrate or a silicon substrate like
if you say it's important that we have a body then what is important about having a body right like
what are the crucial physical things you know how to how does having a body allow us to exploit the
laws of physics to be conscious in a way that you know a silicon machine would not be able to right
this is the thing that i demand the non-question begging answer to i've never heard it yeah yeah
what like um yeah yeah systems neuroscience like circuit level results that's all normal
they're all one anesthetized
so that's like a good definition of like conscious experience that it is that which is not anesthetized
and we don't even understand how it was yeah well that i mean that might be an okay definition for
like a a a a an organism that we've already agreed is conscious right and then we say okay well well
consciousness is whatever it loses when we anesthetize it but then that doesn't help us much with like
the case of an ai or yeah yeah circuit level yeah yeah that you would say is related to what cnn's doing
the visual system yeah those things do not change to me okay something can compute things and you
even notice the difference between when it's conscious but you could know that it's not experiencing
those things i feel like experience is different from just yeah the circuitry of our system yeah so so
look it's it's possible that we would learn something from anesthesia about the neural basis of
consciousness even if we learned everything that could be learned that way there would remain the
question like why is this not just the sort of executive control system like why does it feel
like anything to be there right that would still be kind of a philosophically unanswerable yeah
yeah but you're good yeah so so uh uh so like 15 years ago like the quantum computing companies
realized that like the way to raise money was to say this is going to revolutionize machine learning
that was what people wanted to hear right so so you know they were happy investors were happy
journalists were happy the only problem was that none of it was true right right right and this
narrative does just become impossible to dislodge right i've been trying on my blog for 20 years but
it's like you know pushing a boulder up the mountain like you know sisyphus like you know i can't really do
anything so so uh you know the the truth is like like it is possible that there will be quantum speed
ups for things that matter in machine learning and ai but as far as we know today those speed ups seem to
be quite modest that's just what i was talking about before right we we know how to get these grover type
speed ups but it's quite it'll be quite a long time before grover type speed ups will be a win in
practice because they need a fault tolerant quantum computer in order to run a fault tolerant quantum
computer uh optimistically might have an overhead of like a million compared to you know a classical
computer so then what you're saying is if n is the number of possible solutions that i have then i need
n to be so large that it is uh much larger than like a million times square root of n right so when does
that happen well that eventually happens but only when n is in the trillions right so
so grover can give you you know advantages but only probably only for very large uh uh problem
instances and and and and for most optimization and machine learning problems that's that's kind of the
best thing that we know is grover type speed ups people have been trying for 20 years now to find
better than grover quantum advantages for machine learning i strongly support people working on that you
know even you know my own students uh work on such things but sometimes you know discoveries have gone
in both directions like we had a really great candidate for an exponential speed up for a practical machine
learning problem which was the netflix problem the problem of like recommending movies to you know or
recommending products to a user under some you know uh idealized model of that and and uh you know there was a
quantum algorithm published in 2016 that got an exponential speed up for over the best known
classical algorithm and so now i had an undergrad in my class here named ewin tang and i gave her a
project to try to prove that this quantum speed up is for real meaning rule out you know so it was not a
question about the quantum algorithm this is a question about classical right can you rule out a similarly
efficient classical algorithm to do the same thing and so she spent a year on this she had you know
several fallacious proofs couldn't do it and then at the end of the year she said to me look i think
i know why i haven't been able to rule out you know a fast classical algorithm i think it's because it's
not true i think you know there is a similarly efficient classical algorithm and i was skeptical but
she turns out to be right and then building on what ewin did this is 2018 a whole bunch of the other
quantum machine learning algorithms that were out there were then dequantized so this was an amazing
thing intellectually it was not so great for the field of quantum machine learning which i think has
has still not recovered from what my student did uh uh seven years ago but we continue to look for you
know you know maybe there's an exponential quantum speed up for a machine learning problem that matters in
practice but if you know and which is not itself about quantum mechanics you know they are sure you can get
that but uh you know exponential quantum speed up for a practical classical machine learning problem
but if so i think we're still looking for the compelling example of that um someone who maybe
someone who hasn't had a chance yet to ask a question yeah
you could you could think of it that way i mean i mean look you could say
you know compute the whole insight of computational complexity theory once it started in the 60s right
so so people uh developed this this whole understanding of what is computable what is not
computable you know building on alan turing in the 1930s right and then in the 60s people started building
actual computers and they realized that often what is computable is just not the relevant question at all
right because like most of what we want to do we know that it's computable right the uh the problem
is merely that the natural way of computing it would take much longer than the age of the universe
right and so now now it becomes a question of resources right of like you know your computer is
embedded in space and time and it only has a certain amount of them right it has a certain amount of
met you know oh i mean i mean uh uh you know you you you know we're we're we're very far from like pro
you know getting to the fundamental limits of what the laws of physics would allow right no one actually
builds a computer that does one step per plank time for example right or that stores you know the the
the the the the other related bound is uh how many bits could you store in a given region and the answer
is about 10 to the 69 bits per square meter of surface area okay this is the most that you can store
in any uh region without that you know putting so much energy into that region that it collapses to a
black hole okay that's called the um the the the the holographic entropy bound yeah so yeah yeah
so we're we're many i should say we're many many orders of magnitude away from you know saturating
this limit or this limit you know like at least you know you know uh dozens of orders of magnitude
away but you know if moore's law were to continue for not that much longer then we would have to get
to those limits right or or stop yeah yeah yeah sure how do we what how do we trust space well what do you
mean by by by trust them yeah okay no and we can just keep going yeah yeah and we can keep going
yeah but then you wake up and realize all of it was yeah yeah so right so yeah so it's interesting i
mean one of the standard ways to like tell whether you're in a dream or not right is just like to look
at your watch and then look at it again right and just say like am i seeing something stable here
right usually when you're in the dream world right if if you can have the presence of mind while you're
in the dream to ask questions like can i read this text and then read it a second time and see the same
thing as i usually at that point actually if it's me i would just wake up right but you know apparently
there are these lucid dreamers who can ask such things while still staying within their dream okay but
but uh but but you you usually you know this this this this this is a you know you could say like
you know the the standard definition like like reality is that which doesn't go away when you stop
believing in it right like you know you could say like the you know the the the real physical world
is you know is the thing that stores information you know external to us that we can't just change
by effort of will right uh yeah okay yeah yeah yeah so i was when i was like really really young
okay literally like couldn't tell the difference between when i was dreaming or being awake really
right so i literally couldn't tell the difference at all and so that was very scary for a long time and
i had a lot of difficulty but when i in order to literally make sense of the world so i could be a
functioning i had to i had to start to figure out like what what is what i'm awake what is what i'm
sleeping and there's like this logic today but okay well how old were you three three okay and you
remember this i see okay well i mean what's and then i got a lot better around 70. i see no i mean
i mean what what what's interesting was that you knew enough to you know ask those questions at all
without without yeah without without you know uh having the answers to them yeah yeah so so so i would
say look um you know you you usually like like when when when someone hands you a computer right like
like like like uh the the the the the uh permanence of reliability of of the space-time manifold is
really is not near the top of your of your your concerns right your your bigger concern is what
if this computer just doesn't work right like what if you know someone you know uh built the computer
wrong right it's buggy it's you know it's it's this or that right so you know one thing we do is we
test things right you know another thing we do is we try to prove correctness of programs
now of course any proof of correctness is only as good as the assumptions that it's based on
right so so like you have to you know assume something like about the reliability of the
physical world right and and and in fact you know even you know the the computers that we use now like
you know a few times per year a cosmic ray is going to pass through uh the you know your microprocessor
and your phone or your your laptop or whatever and it's going to cause an error right now normally
that that just doesn't matter for us if you're running a data center like google or amazon then
that actually does matter right you you you actually have to think about you know uh physical errors
including cosmic ray ones okay but uh um uh i i mean i'm i'm yes you know the the the uh building a
computer you know a precondition for being able to build computers is being able to build any kind
of hardware that is reliable enough that it will do the same thing over and over right and uh uh if we
didn't see that that would you know if if uh if all our attempts to do so you know resulted in hardware
that just uh did like alice in wonderland you know completely different thing each time then then
that might be a good sign that that we're actually in a dream uh yeah um do you believe generative ai
will get us to agi that's a that's a hard question because well part of it depends on the definition
of generative ai right it's like it's one of these things it's like like uh so some people say that
that that that that that that string theory like must work as the the uh the uh the uh great you know
unified theory of physics of quantum gravity and the reason for that is that whatever ends up working
it will be called string theory okay okay so so so likewise with generative ai right it's like you know
whatever whatever ends up working you know people may you know decide that it that it is part of this
paradigm after all right but uh no look look i think that the the um the approach of you know
training on massive data you know has clearly had vastly unbelievably more success than the sort of
logic-based approaches that came before this was you know like the biggest paradigm shift of the field
and you know there was a whole old guard that had invested decades in these like older approaches that
didn't work as well and that had to face this enormous reckoning over that uh fortunately for me
i never had a dog in the fight so i could just immediately say okay yes this approach is working
uh where where where the other one wasn't uh um i i think that that if there is a fundamental barrier
to let's say you know llms you know training the president like doing pretty much all the intellectual
work that we do better than we do it then i do not know what that barrier is okay and that you know
that's the scary thing about the coming decade or decades so you know one way or the other i think
we're going to find out um yeah um if i could ask a very similar question okay a little bit more more
technical okay auto-regressive transformers are going to lead to avi or do you think we're going to have
to figure out i don't i don't know enough to say i really don't know enough to say yeah sorry uh so
maybe like one or two more questions then i don't want to keep everyone yeah all right yeah sure hey
all right what's your take on uh randomness coming from uh very simple rules and deterministic processes
uh well i would say you know a a deterministic process by by definition you know if we also know that
process right then in principle we can compute predict all the outputs of that process and so
they are not random what they might be is pseudo-random right so they might be unpredictable to an
adversary to to an adversary who has only a limited view right and you know one of the great achievements
of theoretical computer science uh in the 1980s uh for example was to formalize you know those
concepts right and so like uh andy yal you know won the turing award you know largely for you know
the modern definition of pseudo-randomness which says that something is pseudo-random if no polynomial
time algorithm can tell it apart from true from truly being random right and so so there are many many
simple deterministic processes that plausibly as far as anyone know you know generate sequences that are
pseudo-random by that definition so you know uh for example many cellular automata you know uh
wolfram's you know rule 30 or rule 110 right very plausibly you know uh will will generate
cryptographically pseudo-random sequences right you know they're not unique in that respect many many
other things will do the same okay but you know that all of that depends you know on the assumption that
p is not equal to np right if p equals np then there is no there is no pseudo-randomness in the yal
cryptographic sense okay but you know even if p is not equal to np we don't know that it follows that
pseudo-randomness exists we know that it exists if and only if one-way functions exist so functions that
are easy to compute but hard to invert right so uh so a big theorem from the 1990s was that one-way
functions exist if it only if pseudo-random generators exist so these so and once you have
those things then you can get started building like the whole rest of modern cryptography right now uh
or at least the the symmetric key kind right if you want public key encryption then you seem to need
something more structured like you don't get that from just a cellular automaton as far as we know right
to get public key encryption like the kind of encryption that you know doesn't require a pre-shared
secret uh there you seem seem to need some special mathematical problem like either factoring discrete
logarithms something involving elliptic curves or lattices okay and then you know this introduces a big
trade-off by the way right because uh the more structure you have in your cryptographic problem the
more danger there is that someone is going to solve that problem you know if not using a classical
computer then maybe using a quantum computer right that's exactly what happened with shore's algorithm
which broke much of the public key encryption that we know about not all of it right but but uh but
most of the public key encryption that's currently used okay but if you just want pseudo-randomness
then that seems like a much more generic thing seems very very plausible that we should have that
you know even in a world with quantum computers you know assuming of course that p is not equal to np
uh all right so maybe like uh um just you like yeah yeah yeah like one more so back to lom's yeah
area of research is like model evaluation yeah and so i was kind of imagining like how working
care scientists and cognitive scientists kind of elaborate on something like cognitive complexity
analogous to computational complexity so there's more of a spectrum of what intelligence is on a
given task you can have some sort of classes of what an intelligent system is yeah so so so so so i
don't know how to define cognitive complexity right like and then there is something i think really
tricky here and really uh that really needs to be understood better like it seems intuitively obvious
that like some l you know lms are smarter than other ones right and we can quantify that by saying
well they get higher scores on these evaluation suites right they get a higher lsat score they get you
know and and and uh and as you make in in in lm smarter in in in some ways it seems to also become
typically become smarter in other ways right and and and you see you know you even see them going through
much of the same progressions that like a human student would go through right like i remember
you know try like messing around with gbt3 a few years ago you know before chat gpt right and uh you
know it was struggling with basic arithmetic so you could say like you know and then and people could
and and did point to it and laugh and say oh you know look it's like barely out of nursery school
right but okay we all know what happened right it's as as you just keep scaling it up it gets to junior
high it gets to high school and now i would say it's in graduate school okay right it can you know
like yes i can design problems that my you know my grad students will be able to solve and that you
know gpt 03 will not uh but it won't be trivial right i'll have to think to to design such problems uh
and and so so there does seem to be some kind of notion of cognitive complexity and yet it seems like
not a very good match for any of the notions of complexity that we know how to formalize like
computational complexity right so like like even you know like i i can explain to you know i can easily
explain to to my eight-year-old let's say you know the factoring problem right and then already you
know i could say you know factor this 3000 digit number you know he can't do it but he understands what
the question is right and you know now we're already maybe beyond the ability of any known
classical algorithm running within the lifetime of the universe right but and yet we haven't we haven't
budged on the cognitive complexity scale like we haven't you know made made the the type of problem
more advanced at all so maybe it's just something about like how much knowledge you know you need how
much you know like my worry is is is you know it's not obvious to me a priority that there is a formal
definition of this cognitive complexity at all like separate from just like the history of human
civilization right like here is like like something is more cognitively complex if you needed to know
more of how things developed in in our civilization in order to understand them or something like that
right very hard to formalize that i would love if someone could do it all right so um i want to let
people get home who want to go home and uh i should also uh help put my kids to sleep
i mean uh thank you for coming thank you for your questions uh thanks for yeah it was an honor to be here yeah
