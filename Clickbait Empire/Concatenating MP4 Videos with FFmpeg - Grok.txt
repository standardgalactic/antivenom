Concatenating MP4 Videos with FFmpeg - Grok
a convert or ffmpeg command to chain together the mp4s (four of them) in the current folder into one movie  "visions of a spirit-seer.mp4"
Here are two options to concatenate four MP4 files into one using either
cat
(simpler) or
ffmpeg
(more robust):
Using
cat
(if the MP4s have compatible codecs):
bash
Collapse
Wrap
Copy
cat *.mp4 >
"visions of a spirit-seer.mp4"
Using
ffmpeg
(recommended, handles codec differences better):
bash
Collapse
Wrap
Copy
ffmpeg -f concat -safe 0 -i <(
for
f
in
*.mp4;
do
echo
"file '
$f
'"
;
done
) -c copy
"visions of a spirit-seer.mp4"
For the
ffmpeg
command:
-f concat
specifies the concat demuxer
-safe 0
allows absolute paths or wildcards
-i <(for f in *.mp4; do echo "file '$f'"; done)
generates a list of all MP4s in the current directory
-c copy
copies the streams without re-encoding (faster, preserves quality)
If you know the exact filenames (e.g., video1.mp4, video2.mp4, video3.mp4, video4.mp4), you could also use:
bash
Collapse
Wrap
Copy
ffmpeg -i video1.mp4 -i video2.mp4 -i video3.mp4 -i video4.mp4 -filter_complex
"[0:v][0:a][1:v][1:a][2:v][2:a][3:v][3:a]concat=n=4:v=1:a=1[v][a]"
-map
"[v]"
-map
"[a]"
"visions of a spirit-seer.mp4"
The
cat
method is simpler but might fail if the videos have different encoding settings. The
ffmpeg
options are more reliable, with the first
ffmpeg
command being easier for multiple files in a directory.
[concat @ 0x562ec378be40] Impossible to open '/dev/fd/01-Kants Ethereal Encounter_simple_compose_01jrebdqgcekaanq4kf5fd9crs.mp4'
/dev/fd/63: No such file or directory
bonobo@Memex:konigsbeurg$ ffmpeg -f concat -safe 0 -i <(for f in *.mp4; do echo "file '$f'"; done) -c copy "visions of a spirit-seer.mp4"
The error you're seeing (
Impossible to open '/dev/fd/01-Kants Ethereal Encounter_simple_compose_01jrebdqgcekaanq4kf5fd9crs.mp4'
) suggests an issue with how the shell is handling the process substitution
<(...)
or the file paths being passed to
ffmpeg
. This can happen due to shell-specific behavior, special characters in filenames, or improper quoting. Let's troubleshoot and provide a more reliable solution.
Likely Cause
The process substitution
<(for f in *.mp4; do echo "file '$f'"; done)
is generating a list of files, but the way it's being interpreted by
ffmpeg
might be breaking due to:
Complex filenames with spaces or special characters (e.g., your file
01-Kants Ethereal Encounter_simple_compose_01jrebdqgcekaanq4kf5fd9crs.mp4
).
Shell expansion issues with
/dev/fd/
.
Solution 1: Create a Temporary Concatenation List
Instead of relying on process substitution, create a temporary text file with the list of MP4 files, which is a more stable approach for
ffmpeg
's
concat
demuxer:
bash
Collapse
Wrap
Copy
# Generate the list of files
for
f
in
*.mp4;
do
echo
"file '
$PWD
/
$f
'"
;
done
> concat_list.txt
# Run ffmpeg with the list
ffmpeg -f concat -safe 0 -i concat_list.txt -c copy
"visions of a spirit-seer.mp4"
# Clean up the temporary file
rm concat_list.txt
Explanation:
for f in *.mp4; do echo "file '$PWD/$f'"; done
loops through all
.mp4
files in the current directory and writes each as a
file '/full/path/to/file.mp4'
line to
concat_list.txt
.
$PWD
ensures absolute paths, which
-safe 0
allows and helps avoid path resolution issues.
-c copy
ensures no re-encoding, making it fast and lossless.
Solution 2: Explicitly List Files (if you know them)
If you only have those four specific files and want to avoid the loop, you can manually specify them in a text file or directly in the command. For example:
Create a file
concat_list.txt
with contents like:
text
Collapse
Wrap
Copy
file '/home/bonobo/konigsbeurg/01-Kants Ethereal Encounter_simple_compose_01jrebdqgcekaanq4kf5fd9crs.mp4'
file '/home/bonobo/konigsbeurg/video2.mp4'
file '/home/bonobo/konigsbeurg/video3.mp4'
file '/home/bonobo/konigsbeurg/video4.mp4'
(Replace with the actual full paths to your files.)
Then run:
bash
Collapse
Wrap
Copy
ffmpeg -f concat -safe 0 -i concat_list.txt -c copy
"visions of a spirit-seer.mp4"
Debugging Tips
Check the file list
: Before running
ffmpeg
, inspect what's being generated:
bash
Collapse
Wrap
Copy
for
f
in
*.mp4;
do
echo
"file '
$f
'"
;
done
Ensure the output looks correct (e.g.,
file '01-Kants Ethereal Encounter_simple_compose_01jrebdqgcekaanq4kf5fd9crs.mp4'
).
Verify file existence
: Ensure all files exist and are readable:
bash
Collapse
Wrap
Copy
ls -l *.mp4
Run with debug
: Add
-loglevel debug
to the
ffmpeg
command to get more detailed output if it still fails.
Try This First
Given your error, start with the temporary file approach (Solution 1). It's more robust and avoids shell quirks. Let me know if you hit another snag!
I would like to compress it as well
To concatenate your four MP4 files
and
compress the output, we'll modify the
ffmpeg
command to include re-encoding instead of just copying the streams (i.e., we'll remove
-c copy
and specify compression settings). Here's how you can do it:
Updated Command with Compression
Using the temporary file approach from before, here's the process:
Generate the concatenation list
:
bash
Collapse
Wrap
Copy
for
f
in
*.mp4;
do
echo
"file '
$PWD
/
$f
'"
;
done
> concat_list.txt
Run
ffmpeg
with compression
:
bash
Collapse
Wrap
Copy
ffmpeg -f concat -safe 0 -i concat_list.txt -vcodec libx264 -crf 23 -preset medium -acodec aac -b:a 128k
"visions of a spirit-seer.mp4"
Clean up
:
bash
Collapse
Wrap
Copy
rm concat_list.txt
Compression Options Explained:
-vcodec libx264
: Uses the H.264 video codec, which is widely supported and efficient.
-crf 23
: Constant Rate Factor (CRF) controls video quality. Lower values (e.g., 18) mean higher quality and larger files; higher values (e.g., 28) mean more compression and smaller files. 23 is a good balance.
-preset medium
: Controls encoding speed vs. compression efficiency. Options include
ultrafast
,
superfast
,
veryfast
,
faster
,
fast
,
medium
,
slow
,
slower
,
veryslow
. Slower presets yield better compression but take longer.
-acodec aac
: Uses AAC for audio, a common and efficient codec.
-b:a 128k
: Sets the audio bitrate to 128 kbps, a decent quality for most purposes. You can adjust to 64k for smaller files or 192k/256k for better audio.
Adjusting Compression
More compression
: Increase
-crf
(e.g., 28) and lower
-b:a
(e.g., 64k).
bash
Collapse
Wrap
Copy
ffmpeg -f concat -safe 0 -i concat_list.txt -vcodec libx264 -crf 28 -preset slow -acodec aac -b:a 64k
"visions of a spirit-seer.mp4"
Higher quality
: Decrease
-crf
(e.g., 18) and increase
-b:a
(e.g., 256k).
bash
Collapse
Wrap
Copy
ffmpeg -f concat -safe 0 -i concat_list.txt -vcodec libx264 -crf 18 -preset slow -acodec aac -b:a 256k
"visions of a spirit-seer.mp4"
Notes
Processing Time
: Unlike
-c copy
, re-encoding with compression will take longer, especially with slower presets.
File Size
: The output size depends on the CRF, preset, and audio bitrate. You can experiment to find the right balance for your needs.
Compatibility
: The settings above (H.264 + AAC in MP4) are compatible with most modern devices and players.
Let me know if you want to tweak the settings further or need help with something specific!
Yeah update my script: # Generate the list of files
for f in *.mp4; do echo "file '$PWD/$f'"; done > concat_list.txt

# Run ffmpeg with the list
ffmpeg -f concat -safe 0 -i concat_list.txt -c copy "Visions of a Spirit-Seer.mp4"

# Clean up the temporary file
rm concat_list.txt
Here's your updated script with compression added using
ffmpeg
. I've incorporated the H.264 video codec with a CRF of 23, a medium preset, and AAC audio at 128 kbps, as discussed earlier. You can adjust these parameters as needed:
bash
Collapse
Wrap
Copy
#!/bin/bash
# Generate the list of files
for
f
in
*.mp4;
do
echo
"file '
$PWD
/
$f
'"
;
done
> concat_list.txt
# Run ffmpeg with the list and compression
ffmpeg -f concat -safe 0 -i concat_list.txt -vcodec libx264 -crf 23 -preset medium -acodec aac -b:a 128k
"Visions of a Spirit-Seer.mp4"
# Clean up the temporary file
rm concat_list.txt
Changes Made
Removed
-c copy
to enable re-encoding for compression.
Added
-vcodec libx264 -crf 23 -preset medium
for video compression.
Added
-acodec aac -b:a 128k
for audio compression.
Customization
For
smaller files
: Change
-crf 23
to
-crf 28
and/or
-b:a 128k
to
-b:a 64k
.
For
higher quality
: Change
-crf 23
to
-crf 18
and/or
-b:a 128k
to
-b:a 256k
.
For
faster encoding
: Change
-preset medium
to
-preset fast
or
-preset veryfast
.
For
better compression
: Change
-preset medium
to
-preset slow
.
Running the Script
Save it (e.g., as
concat_compress.sh
).
Make it executable:
chmod +x concat_compress.sh
.
Run it:
./concat_compress.sh
.
Let me know if you'd like further adjustments!
I would like it to use the same thumbnail as the first file
To set the thumbnail (or poster frame) of the output video
"Visions of a Spirit-Seer.mp4"
to match the thumbnail of the first input MP4 file, we need to extract the thumbnail from the first file and then apply it to the output. Unfortunately,
ffmpeg
doesn't directly copy thumbnails between files in a simple way during concatenation, so we'll handle this in two steps: extract the thumbnail from the first file and then embed it into the output.
Here's the updated script:
bash
Collapse
Wrap
Copy
#!/bin/bash
# Get the first MP4 file in the directory
first_file=$(ls *.mp4 | head -n 1)
# Extract the thumbnail from the first file
ffmpeg -i
"
$first_file
"
-vf
"thumbnail"
-frames:v 1 -q:v 2 temp_thumbnail.jpg
# Generate the list of files
for
f
in
*.mp4;
do
echo
"file '
$PWD
/
$f
'"
;
done
> concat_list.txt
# Run ffmpeg with the list, compression, and attach the thumbnail
ffmpeg -f concat -safe 0 -i concat_list.txt -vcodec libx264 -crf 23 -preset medium -acodec aac -b:a 128k -i temp_thumbnail.jpg -map 0:v -map 0:a -map 1 -disposition:v:1 attached_pic
"Visions of a Spirit-Seer.mp4"
# Clean up the temporary files
rm concat_list.txt temp_thumbnail.jpg
Explanation of Changes
Identify the first file
:
first_file=$(ls *.mp4 | head -n 1)
grabs the first MP4 file in alphabetical order. This assumes the "first file" is the earliest in the directory listing. If you have a specific file in mind (e.g.,
01-Kants Ethereal Encounter...
), replace this line with
first_file="your_specific_file.mp4"
.
Extract the thumbnail
:
ffmpeg -i "$first_file" -vf "thumbnail" -frames:v 1 -q:v 2 temp_thumbnail.jpg
:
-vf "thumbnail"
: Selects a representative frame (often the "best" thumbnail based on content analysis).
-frames:v 1
: Outputs only one frame.
-q:v 2
: Sets JPEG quality (2 is high quality; range is 2-31, lower is better).
Outputs to
temp_thumbnail.jpg
.
Concatenate and attach the thumbnail
:
-i temp_thumbnail.jpg
: Adds the extracted thumbnail as an input.
-map 0:v -map 0:a -map 1
: Maps the video and audio from the concatenated stream (input 0) and the thumbnail (input 1).
-disposition:v:1 attached_pic
: Sets the second video stream (the thumbnail) as the attached picture (thumbnail) for the output file.
Notes
Thumbnail Selection
: The
thumbnail
filter picks a frame that's visually representative. If you want a specific time (e.g., the first frame), replace
-vf "thumbnail"
with
-ss 0
(seeks to 0 seconds).
File Order
: If the order of your MP4s matters, ensure
ls *.mp4
lists them correctly, or manually specify them in
concat_list.txt
.
Dependencies
: This assumes your
ffmpeg
build supports H.264, AAC, and image handling (most do).
Running It
Save as
concat_compress_thumbnail.sh
.
Make executable:
chmod +x concat_compress_thumbnail.sh
.
Run:
./concat_compress_thumbnail.sh
.
The output
"Visions of a Spirit-Seer.mp4"
should now have the same thumbnail as the first input file. Let me know if you need tweaks!
libpostproc    55.  9.100 / 55.  9.100
[mov,mp4,m4a,3gp,3g2,mj2 @ 0x55ece192b800] Auto-inserting h264_mp4toannexb bitstream filter
Input #0, concat, from 'concat_list.txt':
  Duration: N/A, start: 0.000000, bitrate: 5327 kb/s
  Stream #0:0(und): Video: h264 (High) (avc1 / 0x31637661), yuv420p, 854x480, 5327 kb/s, 30 fps, 30 tbr, 90k tbn, 60 tbc
    Metadata:
      handler_name    : VideoHandler
      vendor_id       : [0][0][0][0]
Option b:a (video bitrate (please use -b:v)) cannot be applied to input url temp_thumbnail.jpg -- you are trying to apply an input option to an output file or vice versa. Move this option before the file it belongs to.
Error parsing options for input file temp_thumbnail.jpg.
Error opening input files: Invalid argument
The error occurs because the
-b:a 128k
(audio bitrate) option is being applied to all inputs, including the
temp_thumbnail.jpg
, which is an image and has no audio. We need to ensure that encoding options like
-vcodec
,
-crf
,
-preset
,
-acodec
, and
-b:a
are applied only to the output file
"Visions of a Spirit-Seer.mp4"
, not the inputs.
In
ffmpeg
, options before an
-i
apply to the input that follows, while options after the last
-i
apply to the output. Let's fix the script by rearranging the options:
Updated Script
bash
Collapse
Wrap
Copy
#!/bin/bash
# Get the first MP4 file in the directory
first_file=$(ls *.mp4 | head -n 1)
# Extract the thumbnail from the first file
ffmpeg -i
"
$first_file
"
-vf
"thumbnail"
-frames:v 1 -q:v 2 temp_thumbnail.jpg
# Generate the list of files
for
f
in
*.mp4;
do
echo
"file '
$PWD
/
$f
'"
;
done
> concat_list.txt
# Run ffmpeg with the list, compression, and attach the thumbnail
ffmpeg -f concat -safe 0 -i concat_list.txt -i temp_thumbnail.jpg -map 0:v -map 0:a -map 1 -disposition:v:1 attached_pic -vcodec libx264 -crf 23 -preset medium -acodec aac -b:a 128k
"Visions of a Spirit-Seer.mp4"
# Clean up the temporary files
rm concat_list.txt temp_thumbnail.jpg
Changes Made
Moved encoding options
: The options
-vcodec libx264 -crf 23 -preset medium -acodec aac -b:a 128k
are now placed
after
both inputs (
-i concat_list.txt
and
-i temp_thumbnail.jpg
) and
before
the output file
"Visions of a Spirit-Seer.mp4"
. This ensures they apply only to the output, not the inputs.
Kept mapping and disposition
: The
-map
and
-disposition
options remain before the output options, as they define how inputs are processed.
Why It Failed
In the previous version,
-b:a 128k
came before
-i temp_thumbnail.jpg
, so
ffmpeg
tried to apply an audio bitrate to the JPEG input, which doesn't have audio, causing the error.
Verification
The
[mov,mp4,m4a,3gp,3g2,mj2]
and
h264_mp4toannexb
messages are normal; they indicate
ffmpeg
is processing the MP4s and auto-inserting a filter to handle H.264 bitstreams.
The updated command should now run without the "Error parsing options" message.
Running It
Save the script (e.g.,
concat_compress_thumbnail.sh
).
Make it executable:
chmod +x concat_compress_thumbnail.sh
.
Run:
./concat_compress_thumbnail.sh
.
This should concatenate the videos, compress them, and set the thumbnail from the first file correctly. Let me know if you encounter any more issues!
[mov,mp4,m4a,3gp,3g2,mj2 @ 0x56103dbd6900] Auto-inserting h264_mp4toannexb bitstream filter
Input #0, concat, from 'concat_list.txt':
  Duration: N/A, start: 0.000000, bitrate: 5327 kb/s
  Stream #0:0(und): Video: h264 (High) (avc1 / 0x31637661), yuv420p, 854x480, 5327 kb/s, 30 fps, 30 tbr, 90k tbn, 60 tbc
    Metadata:
      handler_name    : VideoHandler
      vendor_id       : [0][0][0][0]
Input #1, image2, from 'temp_thumbnail.jpg':
  Duration: 00:00:00.04, start: 0.000000, bitrate: 14806 kb/s
  Stream #1:0: Video: mjpeg (Baseline), yuvj420p(pc, bt470bg/unknown/unknown), 854x480, 25 fps, 25 tbr, 25 tbn, 25 tbc
Stream map '0:a' matches no streams.
To ignore this, add a trailing '?' to the map.
bonobo@Memex:konigsbeurg$
The error
Stream map '0:a' matches no streams
occurs because your input MP4 files (listed in
concat_list.txt
) only contain video streams (
Stream #0:0: Video
) and no audio streams (
0:a
). When we use
-map 0:v -map 0:a
in the
ffmpeg
command, it tries to map both video and audio from the concatenated input (
Input #0
), but since there's no audio, it fails.
To fix this, we need to adjust the
-map
options to only map the video stream from the concatenated input (since there's no audio) and still include the thumbnail as the attached picture. Here's the corrected script:
Updated Script
bash
Collapse
Wrap
Copy
#!/bin/bash
# Get the first MP4 file in the directory
first_file=$(ls *.mp4 | head -n 1)
# Extract the thumbnail from the first file
ffmpeg -i
"
$first_file
"
-vf
"thumbnail"
-frames:v 1 -q:v 2 temp_thumbnail.jpg
# Generate the list of files
for
f
in
*.mp4;
do
echo
"file '
$PWD
/
$f
'"
;
done
> concat_list.txt
# Run ffmpeg with the list, compression, and attach the thumbnail (only mapping video)
ffmpeg -f concat -safe 0 -i concat_list.txt -i temp_thumbnail.jpg -map 0:v -map 1 -disposition:v:1 attached_pic -vcodec libx264 -crf 23 -preset medium
"Visions of a Spirit-Seer.mp4"
# Clean up the temporary files
rm concat_list.txt temp_thumbnail.jpg
Changes Made
Removed
-map 0:a
: Since there's no audio stream in
Input #0
(the concatenated MP4s), we only map the video stream with
-map 0:v
.
Removed
-acodec aac -b:a 128k
: These audio options are irrelevant because there's no audio to encode in the output. The output will be video-only, matching the input.
Kept
-map 1
and
-disposition:v:1 attached_pic
: This still attaches the thumbnail from
temp_thumbnail.jpg
(
Input #1
) as the poster frame.
Why It Failed
Your MP4 files lack audio streams, as shown in the input description: only
Stream #0:0(und): Video
is present, with no
Stream #0:1
for audio.
The original command assumed both video and audio existed in the concatenated input, leading to the mapping error.
Notes
Output
: The resulting
"Visions of a Spirit-Seer.mp4"
will be a video-only file with the thumbnail attached, compressed using H.264 with CRF 23 and medium preset.
If Audio is Expected
: If you
intended
for the input files to have audio and think they should, check one with
ffmpeg -i input.mp4
to confirm. If they're missing audio unexpectedly, the issue might be upstream in how those files were created.
Running It
Save as
concat_compress_thumbnail.sh
.
Make executable:
chmod +x concat_compress_thumbnail.sh
.
Run:
./concat_compress_thumbnail.sh
.
This should now work without errors, concatenating the video-only MP4s, compressing them, and setting the thumbnail from the first file. Let me know if you hit any more snags or if you need to add audio handling!
[mp4 @ 0x561d7d55adc0] Could not find tag for codec h264 in stream #1, codec not currently supported in container
Could not write header for output file #0 (incorrect codec parameters ?): Invalid argument
Error initializing output stream 0:1 --
Conversion failed!
The error
Could not find tag for codec h264 in stream #1, codec not currently supported in container
indicates that
ffmpeg
is trying to include the second input stream (
stream #1
, which is the thumbnail from
temp_thumbnail.jpg
) as an H.264 video stream in the output MP4 container, but MP4 doesn't support JPEG or raw H.264 streams in this context. The issue stems from how we're mapping and handling the thumbnail stream.
The goal is to set the thumbnail as the
attached picture
(metadata) for the output MP4, not to include it as a second video stream. We need to adjust the
-map
and
-disposition
options to ensure the thumbnail is treated as cover art rather than a video stream.
Corrected Script
Here's the updated script, fixing the thumbnail handling:
bash
Collapse
Wrap
Copy
#!/bin/bash
# Get the first MP4 file in the directory
first_file=$(ls *.mp4 | head -n 1)
# Extract the thumbnail from the first file
ffmpeg -i
"
$first_file
"
-vf
"thumbnail"
-frames:v 1 -q:v 2 temp_thumbnail.jpg
# Generate the list of files
for
f
in
*.mp4;
do
echo
"file '
$PWD
/
$f
'"
;
done
> concat_list.txt
# Run ffmpeg with the list, compression, and attach the thumbnail as cover art
ffmpeg -f concat -safe 0 -i concat_list.txt -i temp_thumbnail.jpg -map 0:v -c:v libx264 -crf 23 -preset medium -map 1:v -c:v:1 copy -disposition:v:1 attached_pic
"Visions of a Spirit-Seer.mp4"
# Clean up the temporary files
rm concat_list.txt temp_thumbnail.jpg
Changes Made
Adjusted Mapping
:
-map 0:v
: Maps the video stream from the concatenated input (
Input #0
, the MP4s).
-map 1:v
: Maps the video stream from the thumbnail (
Input #1
, the JPEG). We need this to include the thumbnail in the output.
Specified Codec for Streams
:
-c:v libx264 -crf 23 -preset medium
: Applies H.264 encoding to the primary video stream (from
Input #0
).
-c:v:1 copy
: Ensures the thumbnail stream (from
Input #1
) is copied as-is (JPEG format) rather than re-encoded. MP4 containers support JPEG as an attached picture.
Set Thumbnail as Attached Picture
:
-disposition:v:1 attached_pic
: Marks the second video stream (the thumbnail) as the cover art for the MP4. This ensures it's embedded as the thumbnail/poster image, not treated as a playable video stream.
Removed Unnecessary Audio Options
:
Since your inputs have no audio (as confirmed earlier), we don't include
-map 0:a
or audio codecs.
Why It Failed
The previous command used
-map 1 -disposition:v:1 attached_pic
, which mapped the entire
Input #1
(the JPEG) and tried to include it as a video stream. MP4 containers don't support JPEG as a regular video stream, and
ffmpeg
attempted to interpret it incorrectly.
By explicitly mapping the thumbnail's video stream (
-map 1:v
) and copying it with
-c:v:1 copy
, we ensure it's treated as a static image for the cover art.
Notes
Thumbnail Format
: The
temp_thumbnail.jpg
is a JPEG, which MP4 supports as an attached picture. The
-c:v:1 copy
ensures it's embedded without conversion.
Verification
: After running, you can check if the thumbnail is set correctly by viewing the file's properties in a media player or running:
bash
Collapse
Wrap
Copy
ffmpeg -i
"Visions of a Spirit-Seer.mp4"
Look for a stream like
Stream #0:1: Video: mjpeg ... (attached pic)
in the output.
Input Assumptions
: This assumes your MP4s are video-only (no audio) and the first file has a valid video stream for thumbnail extraction.
Running It
Save as
concat_compress_thumbnail.sh
.
Make executable:
chmod +x concat_compress_thumbnail.sh
.
Run:
./concat_compress_thumbnail.sh
.
This should now concatenate the videos, compress them with H.264, and set the thumbnail from the first file as the cover art without errors. Let me know if you encounter further issues!
Ok I would like a command to let my know the length of that file and maybe of the mp3
To check the duration of your output file
"Visions of a Spirit-Seer.mp4"
and any MP3 files in the current directory, you can use
ffprobe
, which is part of the
ffmpeg
suite. Below are commands to get the duration of these files.
Command to Check Duration of "Visions of a Spirit-Seer.mp4"
bash
Collapse
Wrap
Copy
ffprobe -i
"Visions of a Spirit-Seer.mp4"
-show_entries format=duration -v quiet -of compact=p=0:nk=1
Explanation
:
-i "Visions of a Spirit-Seer.mp4"
: Specifies the input file.
-show_entries format=duration
: Extracts the duration from the file's format metadata.
-v quiet
: Suppresses unnecessary output.
-of compact=p=0:nk=1
: Formats the output as a single number (duration in seconds).
Output
: A number like
123.456
(seconds). To convert to minutes, divide by 60 (e.g.,
123.456 / 60 ≈ 2.06
minutes).
For a more human-readable format (e.g.,
HH:MM:SS
):
bash
Collapse
Wrap
Copy
ffprobe -i
"Visions of a Spirit-Seer.mp4"
-show_entries format=duration -v quiet -sexagesimal -of compact=p=0:nk=1
-sexagesimal
: Outputs duration as
HH:MM:SS.milliseconds
, e.g.,
00:02:03.456
.
Command to Check Duration of MP3 Files
If you have one or more MP3 files in the current directory and want their durations, you can use a loop or specify a file. Here are two options:
For a Single MP3 File
(replace
your_file.mp3
with the actual filename):
bash
Collapse
Wrap
Copy
ffprobe -i your_file.mp3 -show_entries format=duration -v quiet -of compact=p=0:nk=1
Outputs duration in seconds (e.g.,
245.789
).
For
HH:MM:SS
format, add
-sexagesimal
:
bash
Collapse
Wrap
Copy
ffprobe -i your_file.mp3 -show_entries format=duration -v quiet -sexagesimal -of compact=p=0:nk=1
For All MP3 Files in the Current Directory
:
bash
Collapse
Wrap
Copy
for
f
in
*.mp3;
do
echo
"File:
$f
"
ffprobe -i
"
$f
"
-show_entries format=duration -v quiet -sexagesimal -of compact=p=0:nk=1
done
Loops through all
.mp3
files.
Outputs the filename and duration in
HH:MM:SS.milliseconds
format, e.g.:
text
Collapse
Wrap
Copy
File: song1.mp3
00:04:05.789
File: song2.mp3
00:03:22.123
Notes
No MP3 Files?
: If there are no MP3 files in the directory, the loop command will output nothing or an error like
*.mp3: No such file or directory
. You can add a check:
bash
Collapse
Wrap
Copy
if
ls *.mp3 >/dev/null 2>&1;
then
for
f
in
*.mp3;
do
echo
"File:
$f
"
ffprobe -i
"
$f
"
-show_entries format=duration -v quiet -sexagesimal -of compact=p=0:nk=1
done
else
echo
"No MP3 files found in the current directory."
fi
Dependencies
: These commands assume
ffprobe
is installed (it comes with
ffmpeg
).
Error Handling
: If
"Visions of a Spirit-Seer.mp4"
doesn't exist,
ffprobe
will output an error like
No such file or directory
. Ensure the file was created successfully.
Example Combined Command
To check both the MP4 and any MP3s in one go:
bash
Collapse
Wrap
Copy
echo
"Duration of Visions of a Spirit-Seer.mp4:"
ffprobe -i
"Visions of a Spirit-Seer.mp4"
-show_entries format=duration -v quiet -sexagesimal -of compact=p=0:nk=1
echo
-e
"\nDurations of MP3 files:"
if
ls *.mp3 >/dev/null 2>&1;
then
for
f
in
*.mp3;
do
echo
"File:
$f
"
ffprobe -i
"
$f
"
-show_entries format=duration -v quiet -sexagesimal -of compact=p=0:nk=1
done
else
echo
"No MP3 files found."
fi
This will output something like:
text
Collapse
Wrap
Copy
Duration of Visions of a Spirit-Seer.mp4:
00:02:03.456
Durations of MP3 files:
File: background_music.mp3
00:04:05.789
Let me know if you need help interpreting the output or tweaking the format!
bonobo@Memex:konigsbeurg$ ls
'#16： Gabe Alfour on Competing Beliefs About Superintelligence [NbMsAWvq0aU].en.vtt'
'01-Kants Ethereal Encounter_simple_compose_01jrebdqgcekaanq4kf5fd9crs.mp4'
'02-Kants Cosmic Debate_simple_compose_01jrebvsp5f3r8q77gm3sbz0s6.mp4'
'03-Kants Cosmic Encounter_simple_compose_01jrejdbzge369md465v0wg0jr.mp4'
'04-Kants Otherworldly Debate_simple_compose_01jredb3dze488b3ht44he6ta4.mp4'
'Visions of a Spirit-Seer.mp4'
 cookies.txt
 generate-movie.sh
 superintelligence.mp3
bonobo@Memex:konigsbeurg$ vim get-length.sh
bonobo@Memex:konigsbeurg$ ./get-length.sh
Duration of Visions of a Spirit-Seer.mp4:
0:00:40.000000

Durations of MP3 files:
File: superintelligence.mp3
1:20:55.680000
Your script
get-length.sh
is working correctly! The output shows:
"Visions of a Spirit-Seer.mp4"
: Duration is
0:00:40.000000
(40 seconds).
"superintelligence.mp3"
: Duration is
1:20:55.680000
(1 hour, 20 minutes, and 55.68 seconds).
Since you've shared the
ls
output and the script results, I assume you're happy with the current setup but might want confirmation or further assistance. Here's what I can infer and offer based on your input:
Verification
MP4 Duration
: The 40-second duration for
"Visions of a Spirit-Seer.mp4"
suggests it successfully concatenated your four input MP4s (
01-Kants...mp4
,
02-Kants...mp4
, etc.). If each input was around 10 seconds, this aligns perfectly (4 × 10 = 40 seconds). You can confirm the individual durations with:
bash
Collapse
Wrap
Copy
for
f
in
0[1-4]-Kants*.mp4;
do
echo
"File:
$f
"
ffprobe -i
"
$f
"
-show_entries format=duration -v quiet -sexagesimal -of compact=p=0:nk=1
done
This will list each input's duration to ensure they sum to 40 seconds.
MP3 Duration
: The
superintelligence.mp3
duration of 1 hour, 20 minutes, and 55.68 seconds matches what you'd expect from a longer audio file (perhaps a podcast or lecture, given the context of "superintelligence").
Your Current
get-length.sh
Based on your output, it looks like you used the combined command I provided:
bash
Collapse
Wrap
Copy
#!/bin/bash
echo
"Duration of Visions of a Spirit-Seer.mp4:"
ffprobe -i
"Visions of a Spirit-Seer.mp4"
-show_entries format=duration -v quiet -sexagesimal -of compact=p=0:nk=1
echo
-e
"\nDurations of MP3 files:"
if
ls *.mp3 >/dev/null 2>&1;
then
for
f
in
*.mp3;
do
echo
"File:
$f
"
ffprobe -i
"
$f
"
-show_entries format=duration -v quiet -sexagesimal -of compact=p=0:nk=1
done
else
echo
"No MP3 files found."
fi
Additional Suggestions
If you'd like to enhance or tweak it:
Round the Output
: The
.680000
milliseconds might be overkill. To simplify to
HH:MM:SS
:
bash
Collapse
Wrap
Copy
ffprobe -i
"Visions of a Spirit-Seer.mp4"
-show_entries format=duration -v quiet -sexagesimal -of compact=p=0:nk=1 | cut -d
'.'
-f1
This trims the microseconds, e.g.,
0:00:40
instead of
0:00:40.000000
.
Updated script:
bash
Collapse
Wrap
Copy
#!/bin/bash
echo
"Duration of Visions of a Spirit-Seer.mp4:"
ffprobe -i
"Visions of a Spirit-Seer.mp4"
-show_entries format=duration -v quiet -sexagesimal -of compact=p=0:nk=1 | cut -d
'.'
-f1
echo
-e
"\nDurations of MP3 files:"
if
ls *.mp3 >/dev/null 2>&1;
then
for
f
in
*.mp3;
do
echo
"File:
$f
"
ffprobe -i
"
$f
"
-show_entries format=duration -v quiet -sexagesimal -of compact=p=0:nk=1 | cut -d
'.'
-f1
done
else
echo
"No MP3 files found."
fi
Output would be:
text
Collapse
Wrap
Copy
Duration of Visions of a Spirit-Seer.mp4:
0:00:40

Durations of MP3 files:
File: superintelligence.mp3
1:20:55
Add Total Duration
: If you want the total duration of all MP3s and the MP4 combined:
bash
Collapse
Wrap
Copy
#!/bin/bash
echo
"Duration of Visions of a Spirit-Seer.mp4:"
mp4_duration=$(ffprobe -i
"Visions of a Spirit-Seer.mp4"
-show_entries format=duration -v quiet -of compact=p=0:nk=1)
echo
"
$mp4_duration
seconds"
echo
-e
"\nDurations of MP3 files:"
total_duration=
$mp4_duration
if
ls *.mp3 >/dev/null 2>&1;
then
for
f
in
*.mp3;
do
echo
"File:
$f
"
duration=$(ffprobe -i
"
$f
"
-show_entries format=duration -v quiet -of compact=p=0:nk=1)
echo
"
$duration
seconds"
total_duration=$(
echo
"
$total_duration
+
$duration
"
| bc)
done
else
echo
"No MP3 files found."
fi
echo
-e
"\nTotal duration (seconds):
$total_duration
"
total_hms=$(
printf
'%02d:%02d:%02d'
$(
echo
"
$total_duration
/3600"
| bc) $(
echo
"(
$total_duration
%3600)/60"
| bc) $(
echo
"
$total_duration
%60"
| bc))
echo
"Total duration (H:M:S):
$total_hms
"
Example output:
text
Collapse
Wrap
Copy
Duration of Visions of a Spirit-Seer.mp4:
40 seconds

Durations of MP3 files:
File: superintelligence.mp3
4855.68 seconds

Total duration (seconds): 4895.68
Total duration (H:M:S): 01:21:35
Let me know if you'd like me to refine it further or if you have questions about the output! Everything looks good so far—your movie is 40 seconds, and your MP3 is a hefty 1 hour and 20 minutes.
Yeah I know it sounds crazy but I want to repeat the movie over and over until it fills the audio to make a new movie "Transdimensional Superintelligence.mp4" with the audio from superintelligence.mp3
That's a wild and creative idea! You want to take your 40-second
"Visions of a Spirit-Seer.mp4"
video and loop it repeatedly to match the duration of your 1-hour, 20-minute, and 55.68-second
"superintelligence.mp3"
audio (4855.68 seconds), then combine them into a new video called
"Transdimensional Superintelligence.mp4"
. Let's make it happen with
ffmpeg
.
Steps and Command
Calculate Repetitions
:
Video duration: 40 seconds.
Audio duration: 4855.68 seconds.
Repetitions needed:
4855.68 / 40 ≈ 121.392
. We'll round up to 122 loops to ensure the video is at least as long as the audio, then trim it to match.
Loop the Video
: Use
ffmpeg
's
-stream_loop
to repeat the video.
Add the Audio
: Overlay the MP3 audio onto the looped video.
Trim to Audio Length
: Ensure the output matches the audio duration exactly.
Keep the Thumbnail
: Reuse the thumbnail from the original video.
Here's the command to do it all in one go:
bash
Collapse
Wrap
Copy
ffmpeg -stream_loop 121 -i
"Visions of a Spirit-Seer.mp4"
-i superintelligence.mp3 -i temp_thumbnail.jpg -map 0:v -map 1:a -map 2:v -c:v libx264 -crf 23 -preset medium -c:a aac -b:a 128k -c:v:1 copy -disposition:v:1 attached_pic -shortest
"Transdimensional Superintelligence.mp4"
Explanation
-stream_loop 121
: Loops the video 121 times plus the original (total 122 plays). Total video duration before trimming:
122 * 40 = 4880
seconds, which exceeds 4855.68 seconds.
-i "Visions of a Spirit-Seer.mp4"
: Input video to loop.
-i superintelligence.mp3
: Input audio to overlay.
-i temp_thumbnail.jpg
: Reuses the thumbnail (assumes you still have it from earlier; if not, re-extract it).
-map 0:v
: Maps the video stream from the looped MP4.
-map 1:a
: Maps the audio stream from the MP3.
-map 2:v
: Maps the thumbnail as a second video stream.
-c:v libx264 -crf 23 -preset medium
: Re-encodes the video with H.264 compression.
-c:a aac -b:a 128k
: Encodes the audio to AAC at 128 kbps (you can adjust this).
-c:v:1 copy -disposition:v:1 attached_pic
: Copies the thumbnail as the attached picture (cover art).
-shortest
: Trims the output to the shortest input duration (here, the audio's 4855.68 seconds).
If
temp_thumbnail.jpg
is Missing
If you don't have
temp_thumbnail.jpg
from earlier, extract it first:
bash
Collapse
Wrap
Copy
ffmpeg -i
"Visions of a Spirit-Seer.mp4"
-vf
"thumbnail"
-frames:v 1 -q:v 2 temp_thumbnail.jpg
Full Script
Here's a complete script to ensure everything works smoothly:
bash
Collapse
Wrap
Copy
#!/bin/bash
# Extract thumbnail if it doesn't exist
if
[ ! -f temp_thumbnail.jpg ];
then
ffmpeg -i
"Visions of a Spirit-Seer.mp4"
-vf
"thumbnail"
-frames:v 1 -q:v 2 temp_thumbnail.jpg
fi
# Create the looped video with audio
ffmpeg -stream_loop 121 -i
"Visions of a Spirit-Seer.mp4"
-i superintelligence.mp3 -i temp_thumbnail.jpg -map 0:v -map 1:a -map 2:v -c:v libx264 -crf 23 -preset medium -c:a aac -b:a 128k -c:v:1 copy -disposition:v:1 attached_pic -shortest
"Transdimensional Superintelligence.mp4"
# Clean up (optional)
# rm temp_thumbnail.jpg
Notes
Duration
: The output will be 4855.68 seconds (1:20:55.68), matching the MP3, with the 40-second video looped ~121.39 times (trimmed to fit).
File Size
: The output will be larger due to the length and re-encoding. Adjust
-crf
(e.g., 28 for smaller size) if needed.
Processing Time
: Re-encoding 80+ minutes of video will take a while, especially with
-preset medium
. Use
-preset faster
or
veryfast
to speed it up (at the cost of larger file size).
Verification
: After running, check the duration:
bash
Collapse
Wrap
Copy
ffprobe -i
"Transdimensional Superintelligence.mp4"
-show_entries format=duration -v quiet -sexagesimal -of compact=p=0:nk=1
It should match
1:20:55.680000
.
Running It
Save as
make_transdimensional.sh
.
Make executable:
chmod +x make_transdimensional.sh
.
Run:
./make_transdimensional.sh
.
You'll end up with
"Transdimensional Superintelligence.mp4"
, a trippy 80-minute video of your 40-second clip looping with the superintelligence audio layered on top. Let me know how it goes or if you want to tweak anything—like adding fades between loops or adjusting quality!
I ran ffmpeg -stream_loop 121 -i "Visions of a Spirit-Seer.mp4" -i superintelligence.mp3 -i temp_thumbnail.jpg -map 0:v -map 1:a -map 2:v -c:v libx264 -crf 23 -preset medium -c:a aac -b:a 128k -c:v:1 copy -disposition:v:1 attached_pic -shortest "Transdimensional Superintelligence.mp4"  but it made a video just one second long
A 1-second output from that command is unexpected and suggests something went wrong with how
ffmpeg
interpreted the inputs or the
-shortest
flag. Let's troubleshoot why
"Transdimensional Superintelligence.mp4"
ended up being only 1 second instead of matching the 4855.68-second duration of
superintelligence.mp3
.
Possible Causes
-shortest
Behavior
: The
-shortest
flag trims the output to the duration of the shortest input. Normally, this should be the audio (4855.68 seconds), but if
ffmpeg
misread one of the inputs (e.g., the thumbnail or video) as being 1 second, it could truncate everything to that.
Thumbnail Input Issue
: The
temp_thumbnail.jpg
is a single frame (static image), and if
ffmpeg
treated it as a video stream with a default duration of 1 second (instead of just metadata), it might have caused
-shortest
to cut to that length.
Input Parsing Error
: If
Visions of a Spirit-Seer.mp4
or
superintelligence.mp3
wasn't read correctly (e.g., corruption or codec issues),
ffmpeg
might have defaulted to a minimal duration.
Looping Failure
: The
-stream_loop 121
might not have applied correctly, leaving the video at its original 40-second duration (or less, if misread), and then
-shortest
picked an even shorter duration.
Debugging Steps
Let's verify each input and fix the command:
Check Input Durations
:
Video:
bash
Collapse
Wrap
Copy
ffprobe -i
"Visions of a Spirit-Seer.mp4"
-show_entries format=duration -v quiet -sexagesimal -of compact=p=0:nk=1
(Should be
0:00:40
.)
Audio:
bash
Collapse
Wrap
Copy
ffprobe -i superintelligence.mp3 -show_entries format=duration -v quiet -sexagesimal -of compact=p=0:nk=1
(Should be
1:20:55.680000
.)
Thumbnail:
bash
Collapse
Wrap
Copy
ffprobe -i temp_thumbnail.jpg -show_entries format=duration -v quiet -sexagesimal -of compact=p=0:nk=1
(Should be
0:00:00.040000
or similar, as it's a single frame.)
Your earlier output confirmed the MP4 is 40 seconds and the MP3 is 4855.68 seconds, so those are likely fine. The thumbnail might be the culprit.
Test Without Thumbnail
: Run a simplified version without the thumbnail to see if looping and audio work:
bash
Collapse
Wrap
Copy
ffmpeg -stream_loop 121 -i
"Visions of a Spirit-Seer.mp4"
-i superintelligence.mp3 -map 0:v -map 1:a -c:v libx264 -crf 23 -preset medium -c:a aac -b:a 128k -shortest
"test_no_thumbnail.mp4"
Check the duration of
test_no_thumbnail.mp4
:
bash
Collapse
Wrap
Copy
ffprobe -i test_no_thumbnail.mp4 -show_entries format=duration -v quiet -sexagesimal -of compact=p=0:nk=1
If this is still 1 second, the issue is with the video looping or audio mapping, not the thumbnail.
Avoid
-shortest
: The thumbnail's short duration might be interfering. Replace
-shortest
with an explicit duration matching the audio:
bash
Collapse
Wrap
Copy
ffmpeg -stream_loop 121 -i
"Visions of a Spirit-Seer.mp4"
-i superintelligence.mp3 -i temp_thumbnail.jpg -map 0:v -map 1:a -map 2:v -c:v libx264 -crf 23 -preset medium -c:a aac -b:a 128k -c:v:1 copy -disposition:v:1 attached_pic -t 4855.68
"Transdimensional Superintelligence.mp4"
-t 4855.68
: Forces the output to 4855.68 seconds (the MP3 duration).
Fixed Command
Assuming the thumbnail's short duration confused
-shortest
, here's the corrected command using an explicit duration:
bash
Collapse
Wrap
Copy
ffmpeg -stream_loop 121 -i
"Visions of a Spirit-Seer.mp4"
-i superintelligence.mp3 -i temp_thumbnail.jpg -map 0:v -map 1:a -map 2:v -c:v libx264 -crf 23 -preset medium -c:a aac -b:a 128k -c:v:1 copy -disposition:v:1 attached_pic -t 4855.68
"Transdimensional Superintelligence.mp4"
Updated Script
To make it reusable and robust:
bash
Collapse
Wrap
Copy
#!/bin/bash
# Extract thumbnail if it doesn't exist
if
[ ! -f temp_thumbnail.jpg ];
then
ffmpeg -i
"Visions of a Spirit-Seer.mp4"
-vf
"thumbnail"
-frames:v 1 -q:v 2 temp_thumbnail.jpg
fi
# Get audio duration
audio_duration=$(ffprobe -i superintelligence.mp3 -show_entries format=duration -v quiet -of compact=p=0:nk=1)
# Create the looped video with audio, matching audio duration
ffmpeg -stream_loop 121 -i
"Visions of a Spirit-Seer.mp4"
-i superintelligence.mp3 -i temp_thumbnail.jpg -map 0:v -map 1:a -map 2:v -c:v libx264 -crf 23 -preset medium -c:a aac -b:a 128k -c:v:1 copy -disposition:v:1 attached_pic -t
"
$audio_duration
"
"Transdimensional Superintelligence.mp4"
# Clean up (optional)
# rm temp_thumbnail.jpg
Why This Should Work
Explicit Duration
:
-t "$audio_duration"
ensures the output matches the MP3's 4855.68 seconds, bypassing any misinterpretation by
-shortest
.
Looping
:
-stream_loop 121
still gives 4880 seconds of video (122 * 40), which is then trimmed to 4855.68 seconds.
Thumbnail
:
-c:v:1 copy -disposition:v:1 attached_pic
embeds the JPEG as cover art without affecting duration.
Verify the Output
After running:
bash
Collapse
Wrap
Copy
ffprobe -i
"Transdimensional Superintelligence.mp4"
-show_entries format=duration -v quiet -sexagesimal -of compact=p=0:nk=1
It should show
1:20:55.680000
. If it's still 1 second, please share the full
ffmpeg
output (with errors) so I can pinpoint the exact issue.
Next Steps
Run the updated command or script and let me know the result. If it's still off, we'll dig deeper—possibly testing the looping independently or checking for file corruption. Your idea is too cool to let a 1-second glitch stop it!
How can Grok help?
Grok 3

